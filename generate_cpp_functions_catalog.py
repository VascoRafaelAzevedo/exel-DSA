"""
Comprehensive C++ DSA Functions Catalog Generator
Generates a multi-sheet Excel workbook with detailed information about C++ Standard Library
functions, algorithms, and container methods commonly used in DSA.

Run: python generate_cpp_functions_catalog.py
Requires: pip install pandas openpyxl
"""

import pandas as pd
from pathlib import Path
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter

# ==============================================================================
# EXAMPLE SHEET: ALGORITHM LIBRARY FUNCTIONS
# ==============================================================================
algorithm_functions = [
    # ==================== SORTING ALGORITHMS ====================
    {
        "Category": "Sorting",
        "Function": "std::sort",
        "Header": "<algorithm>",
        "Signature": "sort(RandomIt first, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(log n)",
        "Description": "Sorts elements in ascending order using introsort (hybrid of quicksort, heapsort, and insertion sort)",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "General purpose sorting; need guaranteed O(n log n); default sorting solution",
        "When NOT to Use": "Need stable sort (use stable_sort); partial sorting sufficient (use partial_sort); already mostly sorted (may use insertion sort)",
        "Example": "sort(v.begin(), v.end()); sort(v.begin(), v.end(), greater<int>());",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Not stable; requires RandomAccessIterator; most commonly used sorting function"
    },
    {
        "Category": "Sorting",
        "Function": "std::stable_sort",
        "Header": "<algorithm>",
        "Signature": "stable_sort(RandomIt first, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(n log² n) worst, O(n log n) if enough memory",
        "Space Complexity": "O(n)",
        "Description": "Sorts elements while preserving the relative order of equivalent elements",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "Need to preserve relative order of equal elements; sorting by multiple criteria",
        "When NOT to Use": "Stability not required (use sort for better performance); limited memory",
        "Example": "stable_sort(v.begin(), v.end(), [](auto& a, auto& b){ return a.second < b.second; });",
        "Real World Frequency": 7,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Guaranteed stable; may need extra memory; slower than sort"
    },
    {
        "Category": "Sorting",
        "Function": "std::partial_sort",
        "Header": "<algorithm>",
        "Signature": "partial_sort(RandomIt first, RandomIt middle, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(n log k) where k = distance(first, middle)",
        "Space Complexity": "O(1)",
        "Description": "Rearranges elements so that [first, middle) contains the smallest elements in sorted order",
        "Arguments": "first: iterator to beginning; middle: iterator defining end of sorted range; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "Only need top K elements sorted; finding K smallest/largest elements",
        "When NOT to Use": "Need all elements sorted; need only single min/max (use min_element/max_element)",
        "Example": "partial_sort(v.begin(), v.begin() + 10, v.end()); // sort only first 10 elements",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "More efficient than full sort when k << n; elements after middle are unspecified order"
    },
    {
        "Category": "Sorting",
        "Function": "std::nth_element",
        "Header": "<algorithm>",
        "Signature": "nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(n) average",
        "Space Complexity": "O(1)",
        "Description": "Partially sorts range so nth element is in its final sorted position; elements before are <= and after are >=",
        "Arguments": "first: iterator to beginning; nth: iterator to element to partition around; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "Finding median; finding kth smallest element; quickselect problems",
        "When NOT to Use": "Need sorted output; need top K elements (use partial_sort)",
        "Example": "nth_element(v.begin(), v.begin() + v.size()/2, v.end()); // median",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Based on quickselect; linear average time; elements around nth are not sorted"
    },
    
    # ==================== SEARCHING ALGORITHMS ====================
    {
        "Category": "Searching",
        "Function": "std::binary_search",
        "Header": "<algorithm>",
        "Signature": "binary_search(ForwardIt first, ForwardIt last, const T& value, Compare comp = {})",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if an element equivalent to value appears in sorted range",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: value to search for; comp: (optional) comparison function",
        "Return Type": "bool",
        "When to Use": "Check existence in sorted range; yes/no queries on sorted data",
        "When NOT to Use": "Need position (use lower_bound/upper_bound); unsorted data (use find)",
        "Example": "if(binary_search(v.begin(), v.end(), 42)) cout << \"Found\";",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Requires sorted range; only returns bool; for position use lower_bound"
    },
    {
        "Category": "Searching",
        "Function": "std::lower_bound",
        "Header": "<algorithm>",
        "Signature": "lower_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp = {})",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element not less than (>=) given value in sorted range",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: value to compare; comp: (optional) comparison function",
        "Return Type": "ForwardIt",
        "When to Use": "Find insertion point for value; find first occurrence in sorted range; range queries",
        "When NOT to Use": "Unsorted data; need exact match only (use find or binary_search)",
        "Example": "auto it = lower_bound(v.begin(), v.end(), 5); // first >= 5",
        "Real World Frequency": 8,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most versatile binary search variant; works with duplicates; returns end() if all elements < value"
    },
    {
        "Category": "Searching",
        "Function": "std::upper_bound",
        "Header": "<algorithm>",
        "Signature": "upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp = {})",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element greater than (>) given value in sorted range",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: value to compare; comp: (optional) comparison function",
        "Return Type": "ForwardIt",
        "When to Use": "Find end of range of equal elements; count duplicates with lower_bound; range queries",
        "When NOT to Use": "Unsorted data; need first occurrence (use lower_bound)",
        "Example": "auto it = upper_bound(v.begin(), v.end(), 5); // first > 5",
        "Real World Frequency": 7,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Pair with lower_bound to find range of equal elements; distance gives count"
    },
    {
        "Category": "Searching",
        "Function": "std::equal_range",
        "Header": "<algorithm>",
        "Signature": "equal_range(ForwardIt first, ForwardIt last, const T& value, Compare comp = {})",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns range [lower_bound, upper_bound) of elements equal to value",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: value to search for; comp: (optional) comparison function",
        "Return Type": "pair<ForwardIt, ForwardIt>",
        "When to Use": "Find all occurrences of value in sorted range; count duplicates efficiently",
        "When NOT to Use": "Only need one bound; unsorted data",
        "Example": "auto [lo, hi] = equal_range(v.begin(), v.end(), 5); int count = hi - lo;",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Combines lower_bound and upper_bound; single log(n) search for both bounds"
    },
    {
        "Category": "Searching",
        "Function": "std::find",
        "Header": "<algorithm>",
        "Signature": "find(InputIt first, InputIt last, const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element equal to value using linear search",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: value to search for",
        "Return Type": "InputIt",
        "When to Use": "Unsorted range; small data; first occurrence needed",
        "When NOT to Use": "Large sorted data (use binary_search/lower_bound); need all occurrences",
        "Example": "auto it = find(v.begin(), v.end(), 42); if(it != v.end()) found;",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Linear search; works on any input iterator; returns end() if not found"
    },
    {
        "Category": "Searching",
        "Function": "std::find_if",
        "Header": "<algorithm>",
        "Signature": "find_if(InputIt first, InputIt last, UnaryPredicate p)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element satisfying predicate",
        "Arguments": "first: iterator to beginning; last: iterator to end; p: unary predicate function",
        "Return Type": "InputIt",
        "When to Use": "Complex search criteria; custom conditions; lambda-based search",
        "When NOT to Use": "Simple equality check (use find); sorted data with simple comparison",
        "Example": "auto it = find_if(v.begin(), v.end(), [](int x){ return x > 10 && x % 2 == 0; });",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Very flexible with lambdas; linear search; common in modern C++"
    },
    
    # ==================== MIN/MAX ALGORITHMS ====================
    {
        "Category": "Min/Max",
        "Function": "std::min_element",
        "Header": "<algorithm>",
        "Signature": "min_element(ForwardIt first, ForwardIt last, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to smallest element in range",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "ForwardIt",
        "When to Use": "Find minimum element and need iterator; custom comparison for min",
        "When NOT to Use": "Only need value (use *min_element or min with initializer_list)",
        "Example": "auto it = min_element(v.begin(), v.end()); int min_val = *it;",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Returns iterator not value; single pass; undefined behavior on empty range"
    },
    {
        "Category": "Min/Max",
        "Function": "std::max_element",
        "Header": "<algorithm>",
        "Signature": "max_element(ForwardIt first, ForwardIt last, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to largest element in range",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "ForwardIt",
        "When to Use": "Find maximum element and need iterator; custom comparison for max",
        "When NOT to Use": "Only need value (use *max_element or max with initializer_list)",
        "Example": "auto it = max_element(v.begin(), v.end()); int max_val = *it;",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Returns iterator not value; single pass; undefined behavior on empty range"
    },
    {
        "Category": "Min/Max",
        "Function": "std::minmax_element",
        "Header": "<algorithm>",
        "Signature": "minmax_element(ForwardIt first, ForwardIt last, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Returns pair of iterators to smallest and largest elements",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "pair<ForwardIt, ForwardIt>",
        "When to Use": "Need both min and max; more efficient than separate calls",
        "When NOT to Use": "Only need one of min or max",
        "Example": "auto [min_it, max_it] = minmax_element(v.begin(), v.end());",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "More efficient than calling min_element and max_element separately; ~1.5n comparisons vs 2n"
    },
    {
        "Category": "Min/Max",
        "Function": "std::clamp",
        "Header": "<algorithm>",
        "Signature": "clamp(const T& v, const T& lo, const T& hi, Compare comp = {})",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Clamps value between lower and upper bounds",
        "Arguments": "v: value to clamp; lo: lower bound; hi: upper bound; comp: (optional) comparison function",
        "Return Type": "const T&",
        "When to Use": "Constrain values to range; boundary checking; saturating arithmetic",
        "When NOT to Use": "Simple min/max (use std::min/max)",
        "Example": "int clamped = clamp(value, 0, 100); // returns value in [0, 100]",
        "Real World Frequency": 7,
        "DSA Training Frequency": 5,
        "C++ Version": "C++17",
        "Notes": "Undefined behavior if lo > hi; returns reference so be careful with temporaries"
    },
    
    # ==================== HEAP ALGORITHMS ====================
    {
        "Category": "Heap",
        "Function": "std::make_heap",
        "Header": "<algorithm>",
        "Signature": "make_heap(RandomIt first, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Converts range into a max heap (or min heap with custom comparator)",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function for heap property",
        "Return Type": "void",
        "When to Use": "Initialize heap from existing data; priority queue implementation; heap sort setup",
        "When NOT to Use": "Need dynamic insertions (use priority_queue); need sorted output (use sort)",
        "Example": "make_heap(v.begin(), v.end()); // max heap\nmake_heap(v.begin(), v.end(), greater<>()); // min heap",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Max heap by default; use with push_heap/pop_heap; underlying structure for priority_queue"
    },
    {
        "Category": "Heap",
        "Function": "std::push_heap",
        "Header": "<algorithm>",
        "Signature": "push_heap(RandomIt first, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element at position last-1 into max heap [first, last-1)",
        "Arguments": "first: iterator to beginning; last: iterator to end (after new element); comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "Add element to heap; manual priority queue implementation",
        "When NOT to Use": "Not maintaining heap (use push_back); use std::priority_queue instead for simplicity",
        "Example": "v.push_back(42); push_heap(v.begin(), v.end());",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Must push_back element first, then call push_heap; assumes [first, last-1) is valid heap"
    },
    {
        "Category": "Heap",
        "Function": "std::pop_heap",
        "Header": "<algorithm>",
        "Signature": "pop_heap(RandomIt first, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Swaps first element with last-1 and makes [first, last-1) a valid heap",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "Remove top element from heap; extract max/min from heap",
        "When NOT to Use": "Not maintaining heap; use std::priority_queue for easier API",
        "Example": "pop_heap(v.begin(), v.end()); int top = v.back(); v.pop_back();",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Moves max to end but doesn't remove it; must pop_back separately; maintains heap property"
    },
    {
        "Category": "Heap",
        "Function": "std::sort_heap",
        "Header": "<algorithm>",
        "Signature": "sort_heap(RandomIt first, RandomIt last, Compare comp = {})",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(1)",
        "Description": "Sorts elements in heap, destroying the heap property",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "void",
        "When to Use": "Convert heap to sorted sequence; heapsort implementation",
        "When NOT to Use": "Need to maintain heap (invalidates heap); general sorting (use std::sort)",
        "Example": "make_heap(v.begin(), v.end()); sort_heap(v.begin(), v.end()); // now sorted",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Destroys heap property; range is sorted after; heapsort algorithm"
    },
    
    # ==================== PERMUTATION ALGORITHMS ====================
    {
        "Category": "Permutation",
        "Function": "std::next_permutation",
        "Header": "<algorithm>",
        "Signature": "next_permutation(BidirIt first, BidirIt last, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Transforms range into next lexicographically greater permutation",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "bool (true if next permutation exists, false if wrapped to first)",
        "When to Use": "Generate all permutations; enumerate possibilities; combinatorial problems",
        "When NOT to Use": "Need random permutation (use shuffle); only need one permutation",
        "Example": "sort(v.begin(), v.end()); do { process(v); } while(next_permutation(v.begin(), v.end()));",
        "Real World Frequency": 4,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Must start with sorted sequence for all permutations; returns false when wraps to first"
    },
    {
        "Category": "Permutation",
        "Function": "std::prev_permutation",
        "Header": "<algorithm>",
        "Signature": "prev_permutation(BidirIt first, BidirIt last, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Transforms range into previous lexicographically smaller permutation",
        "Arguments": "first: iterator to beginning; last: iterator to end; comp: (optional) comparison function",
        "Return Type": "bool (true if previous permutation exists, false if wrapped to last)",
        "When to Use": "Generate permutations in reverse order; undo next_permutation",
        "When NOT to Use": "Forward iteration sufficient (use next_permutation)",
        "Example": "sort(v.rbegin(), v.rend()); do { process(v); } while(prev_permutation(v.begin(), v.end()));",
        "Real World Frequency": 2,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Start with reverse sorted for all permutations backward; less common than next_permutation"
    },
    {
        "Category": "Permutation",
        "Function": "std::reverse",
        "Header": "<algorithm>",
        "Signature": "reverse(BidirIt first, BidirIt last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Reverses the order of elements in range",
        "Arguments": "first: iterator to beginning; last: iterator to end",
        "Return Type": "void",
        "When to Use": "Reverse array/vector/string; palindrome operations; undo sorting",
        "When NOT to Use": "Need reversed copy (use reverse_copy); read-only iteration (use rbegin/rend)",
        "Example": "reverse(v.begin(), v.end()); reverse(s.begin(), s.end()); // reverse string",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "In-place reversal; works on bidirectional iterators; very commonly used"
    },
    {
        "Category": "Permutation",
        "Function": "std::rotate",
        "Header": "<algorithm>",
        "Signature": "rotate(ForwardIt first, ForwardIt middle, ForwardIt last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Rotates elements so that middle becomes the new first element",
        "Arguments": "first: iterator to beginning; middle: iterator to element that becomes new first; last: iterator to end",
        "Return Type": "ForwardIt (iterator to old first element in new position)",
        "When to Use": "Circular shift; move range of elements to front/back; rotate array",
        "When NOT to Use": "Simple swap (use swap or swap_ranges); need copy (use rotate_copy)",
        "Example": "rotate(v.begin(), v.begin() + 2, v.end()); // [1,2,3,4,5] -> [3,4,5,1,2]",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Left rotation; efficient in-place; useful for circular arrays"
    },
    {
        "Category": "Permutation",
        "Function": "std::shuffle",
        "Header": "<algorithm>",
        "Signature": "shuffle(RandomIt first, RandomIt last, URBG&& g)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Randomly shuffles elements using uniform random bit generator",
        "Arguments": "first: iterator to beginning; last: iterator to end; g: random number generator (e.g., mt19937)",
        "Return Type": "void",
        "When to Use": "Randomize order; Fisher-Yates shuffle; random sampling",
        "When NOT to Use": "Need reproducible order; sorted data needed",
        "Example": "random_device rd; mt19937 g(rd()); shuffle(v.begin(), v.end(), g);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Replaced random_shuffle; uniform distribution; needs <random> header for generators"
    },
    
    # ==================== SET OPERATIONS ====================
    {
        "Category": "Set Operations",
        "Function": "std::set_union",
        "Header": "<algorithm>",
        "Signature": "set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt result, Compare comp = {})",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1) excluding output",
        "Description": "Computes union of two sorted ranges",
        "Arguments": "first1, last1: first sorted range; first2, last2: second sorted range; result: output iterator; comp: (optional) comparison",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Merge sorted sets; combine unique elements from both ranges",
        "When NOT to Use": "Unsorted data; need actual set container (use std::set); simple merge (use merge)",
        "Example": "vector<int> result(v1.size() + v2.size()); auto it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());",
        "Real World Frequency": 4,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Both inputs must be sorted; output is sorted; duplicates appear once"
    },
    {
        "Category": "Set Operations",
        "Function": "std::set_intersection",
        "Header": "<algorithm>",
        "Signature": "set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt result, Compare comp = {})",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1) excluding output",
        "Description": "Computes intersection of two sorted ranges",
        "Arguments": "first1, last1: first sorted range; first2, last2: second sorted range; result: output iterator; comp: (optional) comparison",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Find common elements in sorted ranges; intersect sorted arrays",
        "When NOT to Use": "Unsorted data; need hash-based intersection (use unordered_set)",
        "Example": "vector<int> result(min(v1.size(), v2.size())); auto it = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Both inputs must be sorted; output is sorted; linear time intersection"
    },
    {
        "Category": "Set Operations",
        "Function": "std::set_difference",
        "Header": "<algorithm>",
        "Signature": "set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt result, Compare comp = {})",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1) excluding output",
        "Description": "Computes difference of two sorted ranges (elements in first but not in second)",
        "Arguments": "first1, last1: first sorted range; first2, last2: second sorted range; result: output iterator; comp: (optional) comparison",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Find elements unique to first set; remove elements present in second set",
        "When NOT to Use": "Unsorted data; symmetric difference needed (use set_symmetric_difference)",
        "Example": "vector<int> result(v1.size()); auto it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());",
        "Real World Frequency": 4,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Both inputs must be sorted; A - B (not commutative); output is sorted"
    },
    {
        "Category": "Set Operations",
        "Function": "std::set_symmetric_difference",
        "Header": "<algorithm>",
        "Signature": "set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt result, Compare comp = {})",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1) excluding output",
        "Description": "Computes symmetric difference (elements in either set but not in both)",
        "Arguments": "first1, last1: first sorted range; first2, last2: second sorted range; result: output iterator; comp: (optional) comparison",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Find elements unique to each set; XOR operation on sets",
        "When NOT to Use": "Unsorted data; need simple difference (use set_difference)",
        "Example": "vector<int> result(v1.size() + v2.size()); auto it = set_symmetric_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Both inputs must be sorted; (A ∪ B) - (A ∩ B); output is sorted"
    },
    {
        "Category": "Set Operations",
        "Function": "std::includes",
        "Header": "<algorithm>",
        "Signature": "includes(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp = {})",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1)",
        "Description": "Checks if one sorted range includes all elements from another sorted range",
        "Arguments": "first1, last1: first sorted range; first2, last2: second sorted range; comp: (optional) comparison",
        "Return Type": "bool (true if second range is subset of first)",
        "When to Use": "Check if one set is subset of another; validate containment",
        "When NOT to Use": "Unsorted data; single element check (use binary_search/find)",
        "Example": "if(includes(v1.begin(), v1.end(), v2.begin(), v2.end())) cout << \"v2 is subset of v1\";",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Both inputs must be sorted; subset check; handles duplicates"
    },
    
    # ==================== NUMERIC ALGORITHMS ====================
    {
        "Category": "Numeric",
        "Function": "std::accumulate",
        "Header": "<numeric>",
        "Signature": "accumulate(InputIt first, InputIt last, T init, BinaryOp op = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Computes sum or custom fold of range with initial value",
        "Arguments": "first: iterator to beginning; last: iterator to end; init: initial value; op: (optional) binary operation",
        "Return Type": "T (accumulated result)",
        "When to Use": "Sum elements; product of elements; custom aggregation; fold operation",
        "When NOT to Use": "Need parallel reduction (use reduce); floating-point precision critical (consider Kahan summation)",
        "Example": "int sum = accumulate(v.begin(), v.end(), 0); int product = accumulate(v.begin(), v.end(), 1, multiplies<>());",
        "Real World Frequency": 9,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "From <numeric> not <algorithm>; left fold; init value important for empty ranges"
    },
    {
        "Category": "Numeric",
        "Function": "std::reduce",
        "Header": "<numeric>",
        "Signature": "reduce(InputIt first, InputIt last, T init, BinaryOp op = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Like accumulate but operation must be associative and commutative; can be parallelized",
        "Arguments": "first: iterator to beginning; last: iterator to end; init: initial value; op: (optional) associative binary operation",
        "Return Type": "T (reduced result)",
        "When to Use": "Parallel reduction; sum/product with execution policy; modern alternative to accumulate",
        "When NOT to Use": "Operation is not associative/commutative; need specific left-to-right order",
        "Example": "int sum = reduce(execution::par, v.begin(), v.end(), 0); // parallel sum",
        "Real World Frequency": 6,
        "DSA Training Frequency": 4,
        "C++ Version": "C++17",
        "Notes": "Can use execution policies; operation order is unspecified; more efficient for parallel"
    },
    {
        "Category": "Numeric",
        "Function": "std::partial_sum",
        "Header": "<numeric>",
        "Signature": "partial_sum(InputIt first, InputIt last, OutputIt result, BinaryOp op = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1) excluding output",
        "Description": "Computes prefix sums (or custom prefix operation) of range",
        "Arguments": "first: iterator to beginning; last: iterator to end; result: output iterator; op: (optional) binary operation",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Prefix sum arrays; cumulative sums; range sum queries preprocessing",
        "When NOT to Use": "Only need final sum (use accumulate); need suffix sums",
        "Example": "vector<int> prefix(n); partial_sum(v.begin(), v.end(), prefix.begin());",
        "Real World Frequency": 7,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Essential for range queries; can do in-place; result[i] = sum of elements [0..i]"
    },
    {
        "Category": "Numeric",
        "Function": "std::iota",
        "Header": "<numeric>",
        "Signature": "iota(ForwardIt first, ForwardIt last, T value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Fills range with sequentially increasing values starting from value",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: initial value to assign",
        "Return Type": "void",
        "When to Use": "Generate sequence of consecutive integers; initialize index arrays; testing",
        "When NOT to Use": "Need custom sequence (use generate); constant value (use fill)",
        "Example": "vector<int> v(10); iota(v.begin(), v.end(), 1); // [1,2,3,4,5,6,7,8,9,10]",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Useful for creating index arrays; name from APL programming language"
    },
    {
        "Category": "Numeric",
        "Function": "std::gcd",
        "Header": "<numeric>",
        "Signature": "gcd(M m, N n)",
        "Time Complexity": "O(log min(m,n))",
        "Space Complexity": "O(1)",
        "Description": "Computes greatest common divisor of two integers",
        "Arguments": "m: first integer; n: second integer",
        "Return Type": "common_type_t<M,N>",
        "When to Use": "Find GCD; simplify fractions; number theory problems",
        "When NOT to Use": "Need LCM (compute as m*n/gcd(m,n) or use std::lcm)",
        "Example": "int g = gcd(48, 18); // returns 6",
        "Real World Frequency": 5,
        "DSA Training Frequency": 8,
        "C++ Version": "C++17",
        "Notes": "Euclidean algorithm; both arguments must be integers; gcd(0,0) is 0"
    },
    {
        "Category": "Numeric",
        "Function": "std::lcm",
        "Header": "<numeric>",
        "Signature": "lcm(M m, N n)",
        "Time Complexity": "O(log min(m,n))",
        "Space Complexity": "O(1)",
        "Description": "Computes least common multiple of two integers",
        "Arguments": "m: first integer; n: second integer",
        "Return Type": "common_type_t<M,N>",
        "When to Use": "Find LCM; synchronization problems; number theory",
        "When NOT to Use": "Need GCD instead; risk of overflow (LCM can be very large)",
        "Example": "int l = lcm(12, 18); // returns 36",
        "Real World Frequency": 4,
        "DSA Training Frequency": 7,
        "C++ Version": "C++17",
        "Notes": "Uses GCD internally; watch for overflow; lcm(0, x) is 0"
    },
    
    # ==================== PARTITIONING ALGORITHMS ====================
    {
        "Category": "Partitioning",
        "Function": "std::partition",
        "Header": "<algorithm>",
        "Signature": "partition(ForwardIt first, ForwardIt last, UnaryPredicate p)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Reorders elements so that elements satisfying predicate come before those that don't",
        "Arguments": "first: iterator to beginning; last: iterator to end; p: unary predicate function",
        "Return Type": "ForwardIt (iterator to first element of second group)",
        "When to Use": "Split array by condition; quicksort partitioning; separate evens/odds",
        "When NOT to Use": "Need stable partition (use stable_partition); need sorted output (use sort)",
        "Example": "auto it = partition(v.begin(), v.end(), [](int x){ return x % 2 == 0; }); // evens before odds",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Not stable; relative order within groups not preserved; used in quicksort"
    },
    {
        "Category": "Partitioning",
        "Function": "std::stable_partition",
        "Header": "<algorithm>",
        "Signature": "stable_partition(BidirIt first, BidirIt last, UnaryPredicate p)",
        "Time Complexity": "O(n log n) worst, O(n) with extra memory",
        "Space Complexity": "O(n) or O(1)",
        "Description": "Partitions range while preserving relative order within each group",
        "Arguments": "first: iterator to beginning; last: iterator to end; p: unary predicate function",
        "Return Type": "BidirIt (iterator to first element of second group)",
        "When to Use": "Need stable partition; maintain relative order important",
        "When NOT to Use": "Stability not needed (use partition for better performance); memory constrained",
        "Example": "auto it = stable_partition(v.begin(), v.end(), [](int x){ return x > 0; });",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Preserves relative order; may need extra memory; slower than partition"
    },
    {
        "Category": "Partitioning",
        "Function": "std::partition_point",
        "Header": "<algorithm>",
        "Signature": "partition_point(ForwardIt first, ForwardIt last, UnaryPredicate p)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Finds partition point in already partitioned range (first element where predicate is false)",
        "Arguments": "first: iterator to beginning; last: iterator to end; p: unary predicate function",
        "Return Type": "ForwardIt (iterator to partition point)",
        "When to Use": "Find boundary in partitioned data; binary search variant with predicate",
        "When NOT to Use": "Range not partitioned; need to partition first (use partition then partition_point)",
        "Example": "auto it = partition_point(v.begin(), v.end(), [](int x){ return x < 10; });",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Requires partitioned range; logarithmic time; similar to lower_bound but with predicate"
    },
    {
        "Category": "Partitioning",
        "Function": "std::is_partitioned",
        "Header": "<algorithm>",
        "Signature": "is_partitioned(InputIt first, InputIt last, UnaryPredicate p)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if range is partitioned by given predicate",
        "Arguments": "first: iterator to beginning; last: iterator to end; p: unary predicate function",
        "Return Type": "bool",
        "When to Use": "Verify partitioning; validate algorithm preconditions",
        "When NOT to Use": "Range is known to be sorted/partitioned; performance critical path",
        "Example": "if(is_partitioned(v.begin(), v.end(), [](int x){ return x % 2 == 0; })) {...}",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Returns true for empty range; useful for debugging/validation"
    },
    
    # ==================== COMPARISON ALGORITHMS ====================
    {
        "Category": "Comparison",
        "Function": "std::equal",
        "Header": "<algorithm>",
        "Signature": "equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if two ranges are equal element by element",
        "Arguments": "first1, last1: first range; first2: start of second range; p: (optional) comparison predicate",
        "Return Type": "bool",
        "When to Use": "Compare two arrays/vectors; validate equality; custom comparison",
        "When NOT to Use": "Containers (use operator==); need lexicographical comparison (use lexicographical_compare)",
        "Example": "if(equal(v1.begin(), v1.end(), v2.begin())) cout << \"Equal\";",
        "Real World Frequency": 7,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Second range must be at least as long; C++14 added overload taking last2"
    },
    {
        "Category": "Comparison",
        "Function": "std::lexicographical_compare",
        "Header": "<algorithm>",
        "Signature": "lexicographical_compare(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if first range is lexicographically less than second",
        "Arguments": "first1, last1: first range; first2, last2: second range; comp: (optional) comparison function",
        "Return Type": "bool",
        "When to Use": "Dictionary ordering; compare sequences; implement operator<",
        "When NOT to Use": "Equality check (use equal); numeric comparison",
        "Example": "if(lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end())) {...}",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Used by std::vector::operator<; like strcmp for generic ranges"
    },
    {
        "Category": "Comparison",
        "Function": "std::mismatch",
        "Header": "<algorithm>",
        "Signature": "mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p = {})",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Finds first position where two ranges differ",
        "Arguments": "first1, last1: first range; first2: start of second range; p: (optional) comparison predicate",
        "Return Type": "pair<InputIt1, InputIt2> (iterators to first mismatch)",
        "When to Use": "Find difference position; validate partial equality; diff algorithms",
        "When NOT to Use": "Only need yes/no equality (use equal)",
        "Example": "auto [it1, it2] = mismatch(v1.begin(), v1.end(), v2.begin());",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Returns pair of end iterators if ranges are equal; useful for debugging"
    },
    
    # ==================== COPY/MOVE ALGORITHMS ====================
    {
        "Category": "Copy/Move",
        "Function": "std::copy",
        "Header": "<algorithm>",
        "Signature": "copy(InputIt first, InputIt last, OutputIt result)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Copies elements from source range to destination",
        "Arguments": "first: iterator to beginning; last: iterator to end; result: output iterator",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Copy array/vector/range; duplicate data; resize operations",
        "When NOT to Use": "Overlapping ranges (use copy_backward); moving elements (use move)",
        "Example": "vector<int> v2(v1.size()); copy(v1.begin(), v1.end(), v2.begin());",
        "Real World Frequency": 9,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Destination must have space; undefined for overlapping ranges copying forward"
    },
    {
        "Category": "Copy/Move",
        "Function": "std::copy_if",
        "Header": "<algorithm>",
        "Signature": "copy_if(InputIt first, InputIt last, OutputIt result, UnaryPredicate p)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Copies elements that satisfy predicate",
        "Arguments": "first: iterator to beginning; last: iterator to end; result: output iterator; p: unary predicate",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Filter and copy; extract elements matching condition",
        "When NOT to Use": "No filtering (use copy); in-place filtering (use remove_if + erase)",
        "Example": "vector<int> evens; copy_if(v.begin(), v.end(), back_inserter(evens), [](int x){ return x % 2 == 0; });",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Often used with back_inserter; functional programming style"
    },
    {
        "Category": "Copy/Move",
        "Function": "std::copy_n",
        "Header": "<algorithm>",
        "Signature": "copy_n(InputIt first, Size count, OutputIt result)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Copies exactly n elements from source to destination",
        "Arguments": "first: iterator to beginning; count: number of elements to copy; result: output iterator",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Copy fixed number of elements; when you have count not end iterator",
        "When NOT to Use": "Have end iterator (use copy); need all elements",
        "Example": "copy_n(v.begin(), 5, dest.begin()); // copy first 5 elements",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "More convenient when you know count; undefined if source has fewer elements"
    },
    {
        "Category": "Copy/Move",
        "Function": "std::move",
        "Header": "<algorithm>",
        "Signature": "move(InputIt first, InputIt last, OutputIt result)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Moves elements from source range to destination (different from std::move utility)",
        "Arguments": "first: iterator to beginning; last: iterator to end; result: output iterator",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Transfer ownership; move expensive objects; optimize performance",
        "When NOT to Use": "Need to preserve source; simple types (copy is equivalent); overlapping ranges",
        "Example": "vector<string> v2(v1.size()); move(v1.begin(), v1.end(), v2.begin()); // v1 elements now moved",
        "Real World Frequency": 7,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Source elements in valid but unspecified state; more efficient for move-only types"
    },
    {
        "Category": "Copy/Move",
        "Function": "std::swap_ranges",
        "Header": "<algorithm>",
        "Signature": "swap_ranges(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Swaps elements between two ranges",
        "Arguments": "first1, last1: first range; first2: start of second range",
        "Return Type": "ForwardIt2 (iterator past last element swapped in second range)",
        "When to Use": "Exchange two arrays/ranges; in-place swap of ranges",
        "When NOT to Use": "Swapping containers (use container::swap); single elements (use std::swap)",
        "Example": "swap_ranges(v1.begin(), v1.end(), v2.begin()); // swap all elements",
        "Real World Frequency": 4,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Ranges can overlap if properly arranged; second range must be large enough"
    },
    
    # ==================== FILL/GENERATE ALGORITHMS ====================
    {
        "Category": "Fill/Generate",
        "Function": "std::fill",
        "Header": "<algorithm>",
        "Signature": "fill(ForwardIt first, ForwardIt last, const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Assigns given value to all elements in range",
        "Arguments": "first: iterator to beginning; last: iterator to end; value: value to assign",
        "Return Type": "void",
        "When to Use": "Initialize array with value; reset elements; set default values",
        "When NOT to Use": "Need different values (use generate); zero initialization (use value initialization)",
        "Example": "fill(v.begin(), v.end(), 0); // set all to 0",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Simple and efficient; common for initialization"
    },
    {
        "Category": "Fill/Generate",
        "Function": "std::fill_n",
        "Header": "<algorithm>",
        "Signature": "fill_n(OutputIt first, Size count, const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Assigns value to first n elements",
        "Arguments": "first: iterator to beginning; count: number of elements; value: value to assign",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Fill fixed number of elements; have count not end iterator",
        "When NOT to Use": "Have end iterator (use fill)",
        "Example": "fill_n(v.begin(), 10, 42); // set first 10 elements to 42",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Convenient with count; undefined if range too small"
    },
    {
        "Category": "Fill/Generate",
        "Function": "std::generate",
        "Header": "<algorithm>",
        "Signature": "generate(ForwardIt first, ForwardIt last, Generator gen)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Assigns values generated by function to elements in range",
        "Arguments": "first: iterator to beginning; last: iterator to end; gen: generator function (takes no args)",
        "Return Type": "void",
        "When to Use": "Generate random numbers; create sequences with function; populate with computed values",
        "When NOT to Use": "Constant value (use fill); consecutive integers (use iota)",
        "Example": "generate(v.begin(), v.end(), [](){ return rand() % 100; });",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Generator called for each element; useful with lambdas and random generators"
    },
    {
        "Category": "Fill/Generate",
        "Function": "std::generate_n",
        "Header": "<algorithm>",
        "Signature": "generate_n(OutputIt first, Size count, Generator gen)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Assigns values generated by function to first n elements",
        "Arguments": "first: iterator to beginning; count: number of elements; gen: generator function",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Generate fixed number of elements; have count not end iterator",
        "When NOT to Use": "Have end iterator (use generate); constant value (use fill_n)",
        "Example": "generate_n(back_inserter(v), 10, [](){ return rand(); });",
        "Real World Frequency": 5,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Often used with back_inserter; convenient for variable-size containers"
    },
    
    # ==================== TRANSFORM ALGORITHMS ====================
    {
        "Category": "Transform",
        "Function": "std::transform (unary)",
        "Header": "<algorithm>",
        "Signature": "transform(InputIt first1, InputIt last1, OutputIt result, UnaryOp op)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Applies function to each element and stores result",
        "Arguments": "first1, last1: input range; result: output iterator; op: unary operation",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Map function over elements; convert types; apply operation to all",
        "When NOT to Use": "Need filtering (use copy_if); simple copy (use copy)",
        "Example": "transform(v.begin(), v.end(), v.begin(), [](int x){ return x * 2; });",
        "Real World Frequency": 9,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Can transform in-place; functional programming map operation"
    },
    {
        "Category": "Transform",
        "Function": "std::transform (binary)",
        "Header": "<algorithm>",
        "Signature": "transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt result, BinaryOp op)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Applies binary function to pairs of elements from two ranges",
        "Arguments": "first1, last1: first input range; first2: second input range; result: output iterator; op: binary operation",
        "Return Type": "OutputIt (iterator past last element written)",
        "When to Use": "Element-wise operations on two arrays; zip operation; combine ranges",
        "When NOT to Use": "Single range (use unary transform); reduction (use inner_product/accumulate)",
        "Example": "transform(v1.begin(), v1.end(), v2.begin(), result.begin(), plus<>());",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Second range must be large enough; can do element-wise arithmetic"
    },
    {
        "Category": "Transform",
        "Function": "std::for_each",
        "Header": "<algorithm>",
        "Signature": "for_each(InputIt first, InputIt last, UnaryFunction f)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Applies function to each element in range",
        "Arguments": "first: iterator to beginning; last: iterator to end; f: unary function to apply",
        "Return Type": "UnaryFunction (the function object, possibly modified)",
        "When to Use": "Apply side effects; print elements; accumulate with state in function object",
        "When NOT to Use": "Range-based for loop more readable; transforming elements (use transform)",
        "Example": "for_each(v.begin(), v.end(), [](int x){ cout << x << ' '; });",
        "Real World Frequency": 7,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Returns function object (can accumulate state); range-for often clearer in modern C++"
    },
]


# ==============================================================================
# VECTOR CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
vector_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "vector()",
        "Signature": "vector()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty vector",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty vector; will add elements later",
        "When NOT to Use": "Know size in advance (use size constructor); have initial values",
        "Example": "vector<int> v;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "No memory allocation; capacity is 0; most common constructor"
    },
    {
        "Category": "Construction",
        "Function": "vector(size_type n)",
        "Signature": "vector(size_type n, const T& value = T())",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs vector with n elements, each initialized to value (or default)",
        "Arguments": "n: number of elements; value: (optional) value to initialize each element",
        "Return Type": "N/A (constructor)",
        "When to Use": "Pre-allocate with known size; initialize DP tables; create filled arrays",
        "When NOT to Use": "Need different values per element (use loop/generate); empty vector needed",
        "Example": "vector<int> v(100); vector<int> v2(100, -1);",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Very common in competitive programming; initializes all elements"
    },
    {
        "Category": "Construction",
        "Function": "vector(initializer_list)",
        "Signature": "vector(initializer_list<T> init)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs vector from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases; small datasets",
        "When NOT to Use": "Large datasets; dynamic initialization",
        "Example": "vector<int> v = {1, 2, 3, 4, 5};",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Clean syntax; modern C++ style; very readable"
    },
    {
        "Category": "Construction",
        "Function": "vector(Iterator first, Iterator last)",
        "Signature": "vector(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs vector from range [first, last)",
        "Arguments": "first: iterator to beginning; last: iterator to end",
        "Return Type": "N/A (constructor)",
        "When to Use": "Copy subrange; convert from other containers; slice arrays",
        "When NOT to Use": "Copy entire container (use copy constructor)",
        "Example": "vector<int> v2(v1.begin(), v1.begin() + 10);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Useful for slicing; works with any input iterator"
    },
    {
        "Category": "Construction",
        "Function": "vector(const vector& other)",
        "Signature": "vector(const vector& other)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Copy constructor - creates deep copy",
        "Arguments": "other: vector to copy from",
        "Return Type": "N/A (constructor)",
        "When to Use": "Need independent copy; pass by value; backup data",
        "When NOT to Use": "Can use reference; expensive for large vectors (consider move)",
        "Example": "vector<int> v2(v1); vector<int> v3 = v1;",
        "Real World Frequency": 8,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Deep copy; independent memory; automatic with = syntax"
    },
    {
        "Category": "Construction",
        "Function": "vector(vector&& other)",
        "Signature": "vector(vector&& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Move constructor - transfers ownership",
        "Arguments": "other: rvalue reference to vector",
        "Return Type": "N/A (constructor)",
        "When to Use": "Transfer ownership; return from function; optimize performance",
        "When NOT to Use": "Need to keep original; copying small vectors",
        "Example": "vector<int> v2(std::move(v1)); // v1 is now empty",
        "Real World Frequency": 7,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Constant time; leaves source in valid but unspecified state (usually empty)"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "operator[]",
        "Signature": "reference operator[](size_type pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access element at index (no bounds checking)",
        "Arguments": "pos: position of element",
        "Return Type": "reference to element",
        "When to Use": "Fast access; know index is valid; performance critical",
        "When NOT to Use": "Need bounds checking (use at()); index might be invalid",
        "Example": "int x = v[5]; v[3] = 42;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "No bounds checking; undefined behavior if out of range; fastest access"
    },
    {
        "Category": "Element Access",
        "Function": "at",
        "Signature": "reference at(size_type pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access element at index with bounds checking",
        "Arguments": "pos: position of element",
        "Return Type": "reference to element",
        "When to Use": "Need safety; uncertain about bounds; debugging",
        "When NOT to Use": "Performance critical; know bounds are valid (use [])",
        "Example": "try { int x = v.at(100); } catch(out_of_range& e) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Throws out_of_range exception; slower than []; safer for user input"
    },
    {
        "Category": "Element Access",
        "Function": "front",
        "Signature": "reference front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access first element",
        "Arguments": "None",
        "Return Type": "reference to first element",
        "When to Use": "Access/modify first element; readability",
        "When NOT to Use": "Vector might be empty (undefined behavior)",
        "Example": "int first = v.front(); v.front() = 0;",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Equivalent to v[0]; undefined if empty; no bounds check"
    },
    {
        "Category": "Element Access",
        "Function": "back",
        "Signature": "reference back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access last element",
        "Arguments": "None",
        "Return Type": "reference to last element",
        "When to Use": "Access/modify last element; stack operations; readability",
        "When NOT to Use": "Vector might be empty (undefined behavior)",
        "Example": "int last = v.back(); v.back() = 99;",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Equivalent to v[v.size()-1]; undefined if empty; very common in DSA"
    },
    {
        "Category": "Element Access",
        "Function": "data",
        "Signature": "T* data() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns pointer to underlying array",
        "Arguments": "None",
        "Return Type": "T* (pointer to first element)",
        "When to Use": "Interface with C APIs; low-level operations; memcpy",
        "When NOT to Use": "Normal iteration (use iterators/range-for); might reallocate",
        "Example": "int* ptr = v.data(); memcpy(dest, v.data(), v.size() * sizeof(int));",
        "Real World Frequency": 5,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Pointer invalidated on reallocation; useful for C interop"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iteration; algorithm functions; range operations",
        "When NOT to Use": "Range-for more readable; need reverse iteration",
        "Example": "for(auto it = v.begin(); it != v.end(); ++it) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most common iterator; used with algorithms; range-for uses this"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; algorithm functions; range operations",
        "When NOT to Use": "Accessing last element (use back() or end()-1)",
        "Example": "sort(v.begin(), v.end());",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator; don't dereference; used with begin()"
    },
    {
        "Category": "Iterators",
        "Function": "rbegin",
        "Signature": "reverse_iterator rbegin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns reverse iterator to last element",
        "Arguments": "None",
        "Return Type": "reverse_iterator",
        "When to Use": "Reverse iteration; process in reverse order",
        "When NOT to Use": "Need to reverse (use std::reverse); forward iteration",
        "Example": "for(auto it = v.rbegin(); it != v.rend(); ++it) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Iterates backward; ++it moves to previous element"
    },
    {
        "Category": "Iterators",
        "Function": "rend",
        "Signature": "reverse_iterator rend() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns reverse iterator to one before first element",
        "Arguments": "None",
        "Return Type": "reverse_iterator",
        "When to Use": "Reverse iteration termination; reverse algorithms",
        "When NOT to Use": "Forward iteration",
        "Example": "sort(v.rbegin(), v.rend()); // sort in descending order",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Used with rbegin(); can reverse sort with this"
    },
    {
        "Category": "Iterators",
        "Function": "cbegin",
        "Signature": "const_iterator cbegin() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns const iterator to first element",
        "Arguments": "None",
        "Return Type": "const_iterator",
        "When to Use": "Read-only iteration; const correctness; prevent modification",
        "When NOT to Use": "Need to modify elements",
        "Example": "for(auto it = v.cbegin(); it != v.cend(); ++it) { cout << *it; }",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Guarantees const access; good practice in const contexts"
    },
    {
        "Category": "Iterators",
        "Function": "cend",
        "Signature": "const_iterator cend() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns const iterator to one past last element",
        "Arguments": "None",
        "Return Type": "const_iterator",
        "When to Use": "Read-only iteration termination; const correctness",
        "When NOT to Use": "Need to modify elements",
        "Example": "auto it = find(v.cbegin(), v.cend(), 42);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Used with cbegin(); prevents accidental modification"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if vector is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input; loop conditions",
        "When NOT to Use": "Need size (use size()); comparing size to value",
        "Example": "if(!v.empty()) { process(v.back()); }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0; more readable; constant time"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type (usually size_t)",
        "When to Use": "Loop bounds; allocation; size validation",
        "When NOT to Use": "Checking if empty (use empty())",
        "Example": "for(int i = 0; i < v.size(); ++i) { }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most frequently used; constant time; returns unsigned type"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used in practice",
        "When NOT to Use": "Normal size checks (use size()); allocation planning",
        "Example": "size_t max = v.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Implementation defined; usually very large; rarely useful"
    },
    {
        "Category": "Capacity",
        "Function": "reserve",
        "Signature": "void reserve(size_type new_cap)",
        "Time Complexity": "O(n) if reallocation, O(1) otherwise",
        "Space Complexity": "O(n) if reallocation",
        "Description": "Reserves storage for at least new_cap elements",
        "Arguments": "new_cap: new capacity",
        "Return Type": "void",
        "When to Use": "Know final size; avoid reallocations; performance optimization",
        "When NOT to Use": "Unknown size; memory constrained; small vectors",
        "Example": "v.reserve(10000); // then add elements without reallocation",
        "Real World Frequency": 7,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Performance optimization; doesn't change size; prevents iterator invalidation"
    },
    {
        "Category": "Capacity",
        "Function": "capacity",
        "Signature": "size_type capacity() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements that can be held in currently allocated storage",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Debug reallocation issues; performance analysis; memory profiling",
        "When NOT to Use": "Normal programming (internal detail); size checks",
        "Example": "cout << \"Size: \" << v.size() << \" Capacity: \" << v.capacity();",
        "Real World Frequency": 4,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Always >= size(); grows geometrically; implementation dependent"
    },
    {
        "Category": "Capacity",
        "Function": "shrink_to_fit",
        "Signature": "void shrink_to_fit()",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Requests to reduce capacity to fit size (non-binding request)",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reduce memory usage; after removing many elements; memory constrained",
        "When NOT to Use": "Will add more elements; performance critical (causes reallocation)",
        "Example": "v.erase(v.begin() + 1000, v.end()); v.shrink_to_fit();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Non-binding; may do nothing; invalidates iterators if reallocates"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset vector; reuse container; clear data",
        "When NOT to Use": "Will delete vector anyway; need to free memory (doesn't change capacity)",
        "Example": "v.clear(); // size becomes 0, capacity unchanged",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Size becomes 0; capacity unchanged; invalidates iterators"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "iterator insert(const_iterator pos, const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1) amortized",
        "Description": "Inserts element before pos",
        "Arguments": "pos: iterator before which to insert; value: element to insert",
        "Return Type": "iterator to inserted element",
        "When to Use": "Insert in middle; maintain sorted order; specific position",
        "When NOT to Use": "Insert at end (use push_back); frequent insertions (use list)",
        "Example": "auto it = v.insert(v.begin() + 5, 42);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Linear time; shifts elements; may reallocate; returns iterator to new element"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (fill)",
        "Signature": "iterator insert(const_iterator pos, size_type count, const T& value)",
        "Time Complexity": "O(n + count)",
        "Space Complexity": "O(count)",
        "Description": "Inserts count copies of value before pos",
        "Arguments": "pos: iterator before which to insert; count: number of copies; value: element to insert",
        "Return Type": "iterator to first inserted element",
        "When to Use": "Insert multiple same elements; initialize middle portion",
        "When NOT to Use": "Single element (use single insert); at end (use resize or loop with push_back)",
        "Example": "v.insert(v.begin() + 10, 5, 0); // insert five 0s",
        "Real World Frequency": 4,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "May reallocate; shifts existing elements"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (range)",
        "Signature": "iterator insert(const_iterator pos, InputIterator first, InputIterator last)",
        "Time Complexity": "O(n + m) where m = distance(first, last)",
        "Space Complexity": "O(m)",
        "Description": "Inserts elements from range [first, last) before pos",
        "Arguments": "pos: iterator before which to insert; first, last: range to insert",
        "Return Type": "iterator to first inserted element",
        "When to Use": "Merge vectors; insert subrange; combine data",
        "When NOT to Use": "Single element; at end (consider insert at end or append pattern)",
        "Example": "v1.insert(v1.end(), v2.begin(), v2.end()); // append v2 to v1",
        "Real World Frequency": 5,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Can append at end; useful for merging; may reallocate"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "iterator emplace(const_iterator pos, Args&&... args)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1) amortized",
        "Description": "Constructs element in-place before pos",
        "Arguments": "pos: iterator before which to construct; args: arguments to forward to constructor",
        "Return Type": "iterator to emplaced element",
        "When to Use": "Construct complex objects; avoid copies; performance",
        "When NOT to Use": "Simple types (insert is fine); at end (use emplace_back)",
        "Example": "v.emplace(v.begin(), arg1, arg2, arg3); // construct in-place",
        "Real World Frequency": 5,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "More efficient than insert for complex types; perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (single)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes element at pos",
        "Arguments": "pos: iterator to element to remove",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove specific element; iterator-based removal",
        "When NOT to Use": "Remove from end (use pop_back); remove by value (use erase-remove idiom)",
        "Example": "v.erase(v.begin() + 5);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Linear time; shifts elements; invalidates iterators from pos onward"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (range)",
        "Signature": "iterator erase(const_iterator first, const_iterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes elements in range [first, last)",
        "Arguments": "first, last: range to remove",
        "Return Type": "iterator following last removed element",
        "When to Use": "Remove multiple consecutive elements; clear subrange",
        "When NOT to Use": "Single element (use single erase); all elements (use clear)",
        "Example": "v.erase(v.begin() + 10, v.begin() + 20);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Erase-remove idiom uses this; shifts remaining elements"
    },
    {
        "Category": "Modifiers",
        "Function": "push_back",
        "Signature": "void push_back(const T& value)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1) amortized",
        "Description": "Adds element to end",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Build vector; append elements; most common insertion",
        "When NOT to Use": "Insert in middle; construct in-place (use emplace_back)",
        "Example": "v.push_back(42);",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most common modifier; amortized O(1); may reallocate"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_back",
        "Signature": "reference emplace_back(Args&&... args)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1) amortized",
        "Description": "Constructs element in-place at end",
        "Arguments": "args: arguments to forward to constructor",
        "Return Type": "reference to inserted element",
        "When to Use": "Construct complex objects at end; avoid copies; modern C++",
        "When NOT to Use": "Simple types (push_back is fine)",
        "Example": "v.emplace_back(arg1, arg2); // construct in-place",
        "Real World Frequency": 8,
        "DSA Training Frequency": 6,
        "C++ Version": "C++11",
        "Notes": "More efficient than push_back; returns reference (C++17); perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_back",
        "Signature": "void pop_back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes last element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove from end; stack operations; backtracking",
        "When NOT to Use": "Vector might be empty (undefined behavior); need removed value (get with back() first)",
        "Example": "int val = v.back(); v.pop_back();",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Doesn't return value; undefined if empty; constant time; very common in DSA"
    },
    {
        "Category": "Modifiers",
        "Function": "resize (value)",
        "Signature": "void resize(size_type count, const T& value = T())",
        "Time Complexity": "O(n) where n is difference",
        "Space Complexity": "O(n) if growing",
        "Description": "Resizes container to contain count elements",
        "Arguments": "count: new size; value: (optional) value for new elements",
        "Return Type": "void",
        "When to Use": "Adjust size; pre-size for known data; shrink or grow",
        "When NOT to Use": "Just reserve space (use reserve); building incrementally (use push_back)",
        "Example": "v.resize(100); v.resize(50, -1);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Can grow or shrink; new elements default-initialized or set to value"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(vector& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another vector",
        "Arguments": "other: vector to swap with",
        "Return Type": "void",
        "When to Use": "Exchange vectors; optimize moves; swap-based algorithms",
        "When NOT to Use": "Copy needed; different types",
        "Example": "v1.swap(v2); swap(v1, v2); // both work",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps internal pointers; doesn't invalidate iterators to other container"
    },
]


# ==============================================================================
# MAP CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
map_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "map()",
        "Signature": "map()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty map",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty map; will add elements later; most common constructor",
        "When NOT to Use": "Have initial key-value pairs (use initializer_list)",
        "Example": "map<string, int> m;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Red-black tree implementation; keys sorted; O(log n) operations"
    },
    {
        "Category": "Construction",
        "Function": "map(initializer_list)",
        "Signature": "map(initializer_list<value_type> init)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs map from initializer list of key-value pairs",
        "Arguments": "init: initializer list with {key, value} pairs",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known key-value pairs; test cases; configuration",
        "When NOT to Use": "Large datasets; dynamic initialization",
        "Example": "map<string, int> m = {{\"Alice\", 25}, {\"Bob\", 30}};",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Clean modern syntax; automatically sorted by key"
    },
    {
        "Category": "Construction",
        "Function": "map(Iterator first, Iterator last)",
        "Signature": "map(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs map from range of key-value pairs",
        "Arguments": "first: iterator to beginning; last: iterator to end",
        "Return Type": "N/A (constructor)",
        "When to Use": "Copy subrange; convert from other maps; filter entries",
        "When NOT to Use": "Copy entire map (use copy constructor)",
        "Example": "map<int, string> m2(m1.begin(), m1.end());",
        "Real World Frequency": 5,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Works with any input iterator; elements sorted during construction"
    },
    {
        "Category": "Construction",
        "Function": "map(const map& other)",
        "Signature": "map(const map& other)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Copy constructor - creates deep copy",
        "Arguments": "other: map to copy from",
        "Return Type": "N/A (constructor)",
        "When to Use": "Need independent copy; backup data; pass by value",
        "When NOT to Use": "Can use reference; expensive for large maps (consider move)",
        "Example": "map<int, string> m2(m1); map<int, string> m3 = m1;",
        "Real World Frequency": 7,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Linear time copy; independent tree structure"
    },
    {
        "Category": "Construction",
        "Function": "map(map&& other)",
        "Signature": "map(map&& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Move constructor - transfers ownership",
        "Arguments": "other: rvalue reference to map",
        "Return Type": "N/A (constructor)",
        "When to Use": "Transfer ownership; return from function; optimize performance",
        "When NOT to Use": "Need to keep original; small maps",
        "Example": "map<int, string> m2(std::move(m1)); // m1 is now empty",
        "Real World Frequency": 6,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Constant time; leaves source empty"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "operator[]",
        "Signature": "mapped_type& operator[](const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Access or insert element with key; creates default value if key doesn't exist",
        "Arguments": "key: key of element",
        "Return Type": "reference to mapped value",
        "When to Use": "Insert with default value; counting/frequency maps; simple access",
        "When NOT to Use": "Check existence without inserting (use find/contains); const map (not available)",
        "Example": "m[\"key\"] = 42; int val = m[\"key\"]; m[key]++; // counting",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most common access; inserts if missing; not available for const maps"
    },
    {
        "Category": "Element Access",
        "Function": "at",
        "Signature": "mapped_type& at(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Access element with key; throws exception if key doesn't exist",
        "Arguments": "key: key of element",
        "Return Type": "reference to mapped value",
        "When to Use": "Need exception on missing key; const map access; bounds checking",
        "When NOT to Use": "Want to insert if missing (use []); performance critical",
        "Example": "try { int val = m.at(\"key\"); } catch(out_of_range& e) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Throws out_of_range; doesn't insert; works with const maps"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element (smallest key)",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate in sorted order; range operations; algorithms",
        "When NOT to Use": "Need specific key (use find); reverse order (use rbegin)",
        "Example": "for(auto it = m.begin(); it != m.end(); ++it) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Sorted order iteration; bidirectional iterator"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing last element (use rbegin or --end)",
        "Example": "auto it = m.find(key); if(it != m.end()) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator; don't dereference"
    },
    {
        "Category": "Iterators",
        "Function": "rbegin",
        "Signature": "reverse_iterator rbegin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns reverse iterator to last element (largest key)",
        "Arguments": "None",
        "Return Type": "reverse_iterator",
        "When to Use": "Iterate in reverse sorted order; largest to smallest",
        "When NOT to Use": "Forward iteration sufficient",
        "Example": "for(auto it = m.rbegin(); it != m.rend(); ++it) { }",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Reverse sorted order; ++it moves to smaller keys"
    },
    {
        "Category": "Iterators",
        "Function": "rend",
        "Signature": "reverse_iterator rend() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns reverse iterator to one before first element",
        "Arguments": "None",
        "Return Type": "reverse_iterator",
        "When to Use": "Reverse iteration termination",
        "When NOT to Use": "Forward iteration",
        "Example": "for(auto it = m.rbegin(); it != m.rend(); ++it) { }",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Used with rbegin()"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if map is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input; loop conditions",
        "When NOT to Use": "Need size (use size())",
        "Example": "if(!m.empty()) { process(m); }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0; more readable"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type (usually size_t)",
        "When to Use": "Get count of elements; size validation; iteration bounds",
        "When NOT to Use": "Checking if empty (use empty())",
        "Example": "cout << \"Map has \" << m.size() << \" elements\";",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Constant time; cached value"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used in practice",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = m.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Implementation defined; rarely useful"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset map; reuse container; clear data",
        "When NOT to Use": "Will delete map anyway",
        "Example": "m.clear(); // size becomes 0",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Destroys all elements; size becomes 0"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "pair<iterator, bool> insert(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element if key doesn't exist",
        "Arguments": "value: pair<key, value> to insert",
        "Return Type": "pair<iterator, bool> - iterator to element, bool indicating if inserted",
        "When to Use": "Insert without overwriting; check if key exists; conditional insert",
        "When NOT to Use": "Want to overwrite (use [] or insert_or_assign)",
        "Example": "auto [it, inserted] = m.insert({key, value}); if(inserted) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Returns false if key exists; doesn't overwrite; returns iterator to element"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (with hint)",
        "Signature": "iterator insert(const_iterator hint, const value_type& value)",
        "Time Complexity": "O(log n) worst, O(1) amortized if hint is correct",
        "Space Complexity": "O(1)",
        "Description": "Inserts element with position hint for optimization",
        "Arguments": "hint: iterator suggesting insertion position; value: pair to insert",
        "Return Type": "iterator to inserted or existing element",
        "When to Use": "Sequential insertions; know approximate position",
        "When NOT to Use": "Random insertions; no position knowledge",
        "Example": "auto it = m.end(); for(auto& p : data) it = m.insert(it, p);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Optimization for sequential inserts; hint is suggestion only"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (range)",
        "Signature": "void insert(InputIterator first, InputIterator last)",
        "Time Complexity": "O(m log(n+m)) where m = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Inserts elements from range",
        "Arguments": "first, last: range of pairs to insert",
        "Return Type": "void",
        "When to Use": "Merge maps; bulk insert; combine data",
        "When NOT to Use": "Single element; need return value",
        "Example": "m1.insert(m2.begin(), m2.end()); // merge m2 into m1",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Doesn't overwrite existing keys"
    },
    {
        "Category": "Modifiers",
        "Function": "insert_or_assign",
        "Signature": "pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts or assigns to element with key k",
        "Arguments": "k: key; obj: value to insert or assign",
        "Return Type": "pair<iterator, bool> - iterator to element, bool true if inserted",
        "When to Use": "Upsert operation; insert or update; always assign value",
        "When NOT to Use": "Don't want to overwrite (use insert)",
        "Example": "auto [it, inserted] = m.insert_or_assign(key, value);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++17",
        "Notes": "Modern alternative to []; returns insertion status; efficient"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "pair<iterator, bool> emplace(Args&&... args)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place if key doesn't exist",
        "Arguments": "args: arguments to forward to value_type constructor",
        "Return Type": "pair<iterator, bool> - iterator to element, bool indicating if inserted",
        "When to Use": "Construct complex objects; avoid copies; performance",
        "When NOT to Use": "Simple types (insert is fine); want to overwrite",
        "Example": "m.emplace(key, value); m.emplace(piecewise_construct, forward_as_tuple(k), forward_as_tuple(args...));",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; more efficient than insert for complex types"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_hint",
        "Signature": "iterator emplace_hint(const_iterator hint, Args&&... args)",
        "Time Complexity": "O(log n) worst, O(1) amortized if hint correct",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place with position hint",
        "Arguments": "hint: iterator suggesting position; args: arguments for constructor",
        "Return Type": "iterator to inserted or existing element",
        "When to Use": "Sequential insertions with construction; performance optimization",
        "When NOT to Use": "Random insertions; no position knowledge",
        "Example": "auto it = m.end(); for(...) it = m.emplace_hint(it, k, v);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Combines emplace and hint optimization"
    },
    {
        "Category": "Modifiers",
        "Function": "try_emplace",
        "Signature": "pair<iterator, bool> try_emplace(const key_type& k, Args&&... args)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts in-place if key doesn't exist; doesn't move from args if key exists",
        "Arguments": "k: key; args: arguments for mapped_type constructor",
        "Return Type": "pair<iterator, bool> - iterator to element, bool true if inserted",
        "When to Use": "Conditional insert; don't want to construct if key exists; move-only values",
        "When NOT to Use": "Want to update existing (use insert_or_assign)",
        "Example": "m.try_emplace(key, arg1, arg2); // constructs value only if key new",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++17",
        "Notes": "Doesn't move from arguments if key exists; efficient for expensive objects"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by iterator)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Removes element at iterator position",
        "Arguments": "pos: iterator to element to remove",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove during iteration; have iterator to element",
        "When NOT to Use": "Have key only (use erase by key)",
        "Example": "for(auto it = m.begin(); it != m.end(); ) { if(cond) it = m.erase(it); else ++it; }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Amortized constant time; returns next valid iterator"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by key)",
        "Signature": "size_type erase(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Removes element with specified key",
        "Arguments": "key: key of element to remove",
        "Return Type": "size_type (number of elements removed: 0 or 1)",
        "When to Use": "Remove by key; don't have iterator; simple deletion",
        "When NOT to Use": "During iteration (use iterator version)",
        "Example": "if(m.erase(key)) { cout << \"Removed\"; }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Most common erase; returns count (0 or 1 for map)"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (range)",
        "Signature": "iterator erase(const_iterator first, const_iterator last)",
        "Time Complexity": "O(log n + k) where k = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Removes elements in range [first, last)",
        "Arguments": "first, last: range to remove",
        "Return Type": "iterator following last removed element",
        "When to Use": "Remove multiple consecutive elements in sorted order",
        "When NOT to Use": "Single element; all elements (use clear)",
        "Example": "m.erase(m.begin(), m.find(key)); // remove all before key",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Removes range in tree order"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(map& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another map",
        "Arguments": "other: map to swap with",
        "Return Type": "void",
        "When to Use": "Exchange maps; optimize moves; swap-based algorithms",
        "When NOT to Use": "Different key/value types",
        "Example": "m1.swap(m2); swap(m1, m2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps tree pointers"
    },
    {
        "Category": "Modifiers",
        "Function": "extract (by iterator)",
        "Signature": "node_type extract(const_iterator position)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Removes and returns node handle at iterator",
        "Arguments": "position: iterator to element",
        "Return Type": "node_type (handle to extracted node)",
        "When to Use": "Move elements between maps; modify keys; avoid reallocation",
        "When NOT to Use": "Just removing (use erase); don't need node",
        "Example": "auto nh = m1.extract(it); m2.insert(std::move(nh));",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++17",
        "Notes": "Enables key modification; move between maps without reallocation"
    },
    {
        "Category": "Modifiers",
        "Function": "extract (by key)",
        "Signature": "node_type extract(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Removes and returns node handle for key",
        "Arguments": "key: key of element to extract",
        "Return Type": "node_type (handle to extracted node, empty if not found)",
        "When to Use": "Move element to another map; modify key; splice operation",
        "When NOT to Use": "Just removing (use erase)",
        "Example": "auto nh = m1.extract(key); if(!nh.empty()) m2.insert(std::move(nh));",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++17",
        "Notes": "Returns empty node_type if key not found"
    },
    {
        "Category": "Modifiers",
        "Function": "merge",
        "Signature": "void merge(map& source)",
        "Time Complexity": "O(n log(size() + n))",
        "Space Complexity": "O(1)",
        "Description": "Splices nodes from source map; doesn't copy or move elements",
        "Arguments": "source: map to merge from",
        "Return Type": "void",
        "When to Use": "Merge maps efficiently; combine without copying; unique ownership",
        "When NOT to Use": "Want to keep source; need to handle duplicate keys specially",
        "Example": "m1.merge(m2); // m2 may retain elements with duplicate keys",
        "Real World Frequency": 4,
        "DSA Training Frequency": 3,
        "C++ Version": "C++17",
        "Notes": "No allocation; source retains elements with duplicate keys; very efficient"
    },
    
    # ==================== LOOKUP ====================
    {
        "Category": "Lookup",
        "Function": "count",
        "Signature": "size_type count(const key_type& key) const",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements with key (0 or 1 for map)",
        "Arguments": "key: key to search for",
        "Return Type": "size_type (0 or 1)",
        "When to Use": "Check existence; simple boolean check as count > 0",
        "When NOT to Use": "Need iterator (use find); C++20+ (use contains)",
        "Example": "if(m.count(key)) { cout << \"Found\"; }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Common for existence check; returns 0 or 1 for map"
    },
    {
        "Category": "Lookup",
        "Function": "find",
        "Signature": "iterator find(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Finds element with key",
        "Arguments": "key: key to search for",
        "Return Type": "iterator to element, or end() if not found",
        "When to Use": "Get iterator to element; access without inserting; check and use",
        "When NOT to Use": "Just checking existence (use contains/count); want default value (use [])",
        "Example": "auto it = m.find(key); if(it != m.end()) { use(it->second); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most common lookup; doesn't insert; returns end() if not found"
    },
    {
        "Category": "Lookup",
        "Function": "contains",
        "Signature": "bool contains(const key_type& key) const",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if key exists in map",
        "Arguments": "key: key to check",
        "Return Type": "bool",
        "When to Use": "Simple existence check; modern C++ code; readable",
        "When NOT to Use": "Need iterator (use find); C++17 and earlier (use count/find)",
        "Example": "if(m.contains(key)) { cout << \"Found\"; }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++20",
        "Notes": "Cleaner than count; modern addition; more readable"
    },
    {
        "Category": "Lookup",
        "Function": "lower_bound",
        "Signature": "iterator lower_bound(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element not less than key",
        "Arguments": "key: key to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find insertion point; ordered operations",
        "When NOT to Use": "Exact match only (use find)",
        "Example": "auto it = m.lower_bound(key); // first >= key",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Useful for range queries; returns end() if all < key"
    },
    {
        "Category": "Lookup",
        "Function": "upper_bound",
        "Signature": "iterator upper_bound(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element greater than key",
        "Arguments": "key: key to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find elements after key; ordered operations",
        "When NOT to Use": "Exact match (use find)",
        "Example": "auto it = m.upper_bound(key); // first > key",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Pair with lower_bound for ranges; returns end() if all <= key"
    },
    {
        "Category": "Lookup",
        "Function": "equal_range",
        "Signature": "pair<iterator, iterator> equal_range(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns range of elements matching key [lower_bound, upper_bound)",
        "Arguments": "key: key to search for",
        "Return Type": "pair of iterators defining the range",
        "When to Use": "Get range in one call; multimap-style lookup",
        "When NOT to Use": "Map (range has at most 1 element); only need one bound",
        "Example": "auto [lo, hi] = m.equal_range(key);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "More useful for multimap; single log(n) search for both bounds"
    },
    
    # ==================== OBSERVERS ====================
    {
        "Category": "Observers",
        "Function": "key_comp",
        "Signature": "key_compare key_comp() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns comparison function object for keys",
        "Arguments": "None",
        "Return Type": "key_compare (comparison function)",
        "When to Use": "Get comparator; custom sorting logic; algorithm interop",
        "When NOT to Use": "Normal usage; rarely needed",
        "Example": "auto comp = m.key_comp(); if(comp(k1, k2)) { }",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++98",
        "Notes": "Returns copy of comparison object; rarely used directly"
    },
    {
        "Category": "Observers",
        "Function": "value_comp",
        "Signature": "value_compare value_comp() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns comparison function object for value_type",
        "Arguments": "None",
        "Return Type": "value_compare (compares pairs by key)",
        "When to Use": "Compare pairs; algorithm requirements; custom logic",
        "When NOT to Use": "Normal usage; rarely needed",
        "Example": "auto comp = m.value_comp(); if(comp(*it1, *it2)) { }",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Compares pairs using key comparison; very rarely used"
    },
]


# ==============================================================================
# SET CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
set_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "set()",
        "Signature": "set()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty set",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty set; will add elements later; most common constructor",
        "When NOT to Use": "Have initial values (use initializer_list)",
        "Example": "set<int> s;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Red-black tree; sorted unique elements; O(log n) operations"
    },
    {
        "Category": "Construction",
        "Function": "set(initializer_list)",
        "Signature": "set(initializer_list<value_type> init)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs set from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases; small datasets",
        "When NOT to Use": "Large datasets; dynamic initialization",
        "Example": "set<int> s = {1, 2, 3, 4, 5};",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Automatically removes duplicates; elements sorted"
    },
    {
        "Category": "Construction",
        "Function": "set(Iterator first, Iterator last)",
        "Signature": "set(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs set from range",
        "Arguments": "first: iterator to beginning; last: iterator to end",
        "Return Type": "N/A (constructor)",
        "When to Use": "Remove duplicates from range; convert vector to set; filter data",
        "When NOT to Use": "Copy entire set (use copy constructor)",
        "Example": "set<int> s(v.begin(), v.end()); // unique sorted elements from vector",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Removes duplicates automatically; sorts elements"
    },
    {
        "Category": "Construction",
        "Function": "set(const set& other)",
        "Signature": "set(const set& other)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Copy constructor - creates deep copy",
        "Arguments": "other: set to copy from",
        "Return Type": "N/A (constructor)",
        "When to Use": "Need independent copy; backup data; pass by value",
        "When NOT to Use": "Can use reference; expensive for large sets (consider move)",
        "Example": "set<int> s2(s1); set<int> s3 = s1;",
        "Real World Frequency": 7,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Linear time copy; independent tree structure"
    },
    {
        "Category": "Construction",
        "Function": "set(set&& other)",
        "Signature": "set(set&& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Move constructor - transfers ownership",
        "Arguments": "other: rvalue reference to set",
        "Return Type": "N/A (constructor)",
        "When to Use": "Transfer ownership; return from function; optimize performance",
        "When NOT to Use": "Need to keep original; small sets",
        "Example": "set<int> s2(std::move(s1)); // s1 is now empty",
        "Real World Frequency": 6,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Constant time; leaves source empty"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element (smallest)",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate in sorted order; range operations; algorithms",
        "When NOT to Use": "Need specific value (use find); reverse order (use rbegin)",
        "Example": "for(auto it = s.begin(); it != s.end(); ++it) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Sorted order iteration; bidirectional iterator"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing last element (use rbegin or --end)",
        "Example": "auto it = s.find(val); if(it != s.end()) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator; don't dereference"
    },
    {
        "Category": "Iterators",
        "Function": "rbegin",
        "Signature": "reverse_iterator rbegin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns reverse iterator to last element (largest)",
        "Arguments": "None",
        "Return Type": "reverse_iterator",
        "When to Use": "Iterate in reverse sorted order; largest to smallest",
        "When NOT to Use": "Forward iteration sufficient",
        "Example": "for(auto it = s.rbegin(); it != s.rend(); ++it) { }",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Reverse sorted order; ++it moves to smaller elements"
    },
    {
        "Category": "Iterators",
        "Function": "rend",
        "Signature": "reverse_iterator rend() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns reverse iterator to one before first element",
        "Arguments": "None",
        "Return Type": "reverse_iterator",
        "When to Use": "Reverse iteration termination",
        "When NOT to Use": "Forward iteration",
        "Example": "for(auto it = s.rbegin(); it != s.rend(); ++it) { }",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Used with rbegin()"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if set is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input; loop conditions",
        "When NOT to Use": "Need size (use size())",
        "Example": "if(!s.empty()) { process(s); }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0; more readable"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type (usually size_t)",
        "When to Use": "Get count of elements; size validation; iteration bounds",
        "When NOT to Use": "Checking if empty (use empty())",
        "Example": "cout << \"Set has \" << s.size() << \" unique elements\";",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Constant time; cached value"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used in practice",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = s.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Implementation defined; rarely useful"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset set; reuse container; clear data",
        "When NOT to Use": "Will delete set anyway",
        "Example": "s.clear(); // size becomes 0",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Destroys all elements; size becomes 0"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "pair<iterator, bool> insert(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element if not already present",
        "Arguments": "value: element to insert",
        "Return Type": "pair<iterator, bool> - iterator to element, bool indicating if inserted",
        "When to Use": "Add unique elements; check if already exists; build set",
        "When NOT to Use": "Don't care about duplicates (not applicable for set)",
        "Example": "auto [it, inserted] = s.insert(42); if(inserted) { }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most common modifier; returns false if already exists"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (with hint)",
        "Signature": "iterator insert(const_iterator hint, const value_type& value)",
        "Time Complexity": "O(log n) worst, O(1) amortized if hint correct",
        "Space Complexity": "O(1)",
        "Description": "Inserts element with position hint for optimization",
        "Arguments": "hint: iterator suggesting insertion position; value: element to insert",
        "Return Type": "iterator to inserted or existing element",
        "When to Use": "Sequential insertions; know approximate position",
        "When NOT to Use": "Random insertions; no position knowledge",
        "Example": "auto it = s.end(); for(auto val : data) it = s.insert(it, val);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Optimization for sequential inserts; hint is suggestion only"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (range)",
        "Signature": "void insert(InputIterator first, InputIterator last)",
        "Time Complexity": "O(m log(n+m)) where m = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Inserts elements from range",
        "Arguments": "first, last: range of elements to insert",
        "Return Type": "void",
        "When to Use": "Merge sets; bulk insert; combine data; remove duplicates from range",
        "When NOT to Use": "Single element; need return value",
        "Example": "s1.insert(s2.begin(), s2.end()); // merge s2 into s1\ns.insert(v.begin(), v.end()); // unique elements from vector",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Automatically handles duplicates; very useful for deduplication"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (initializer_list)",
        "Signature": "void insert(initializer_list<value_type> ilist)",
        "Time Complexity": "O(m log(n+m)) where m = ilist.size()",
        "Space Complexity": "O(1)",
        "Description": "Inserts elements from initializer list",
        "Arguments": "ilist: initializer list of elements",
        "Return Type": "void",
        "When to Use": "Add multiple known elements; inline insertion",
        "When NOT to Use": "Single element; have range/container",
        "Example": "s.insert({1, 2, 3, 4, 5});",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++11",
        "Notes": "Clean syntax; modern C++"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "pair<iterator, bool> emplace(Args&&... args)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place if not already present",
        "Arguments": "args: arguments to forward to value_type constructor",
        "Return Type": "pair<iterator, bool> - iterator to element, bool indicating if inserted",
        "When to Use": "Construct complex objects; avoid copies; performance",
        "When NOT to Use": "Simple types (insert is fine); already have object",
        "Example": "s.emplace(arg1, arg2); // construct in-place",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; more efficient than insert for complex types"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_hint",
        "Signature": "iterator emplace_hint(const_iterator hint, Args&&... args)",
        "Time Complexity": "O(log n) worst, O(1) amortized if hint correct",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place with position hint",
        "Arguments": "hint: iterator suggesting position; args: arguments for constructor",
        "Return Type": "iterator to inserted or existing element",
        "When to Use": "Sequential insertions with construction; performance optimization",
        "When NOT to Use": "Random insertions; no position knowledge",
        "Example": "auto it = s.end(); for(...) it = s.emplace_hint(it, args...);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Combines emplace and hint optimization"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by iterator)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Removes element at iterator position",
        "Arguments": "pos: iterator to element to remove",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove during iteration; have iterator to element",
        "When NOT to Use": "Have value only (use erase by value)",
        "Example": "for(auto it = s.begin(); it != s.end(); ) { if(cond) it = s.erase(it); else ++it; }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Amortized constant time; returns next valid iterator"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by value)",
        "Signature": "size_type erase(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Removes element with specified value",
        "Arguments": "value: value of element to remove",
        "Return Type": "size_type (number of elements removed: 0 or 1)",
        "When to Use": "Remove by value; don't have iterator; simple deletion",
        "When NOT to Use": "During iteration (use iterator version)",
        "Example": "if(s.erase(42)) { cout << \"Removed\"; }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most common erase; returns count (0 or 1 for set)"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (range)",
        "Signature": "iterator erase(const_iterator first, const_iterator last)",
        "Time Complexity": "O(log n + k) where k = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Removes elements in range [first, last)",
        "Arguments": "first, last: range to remove",
        "Return Type": "iterator following last removed element",
        "When to Use": "Remove multiple consecutive elements in sorted order",
        "When NOT to Use": "Single element; all elements (use clear)",
        "Example": "s.erase(s.begin(), s.find(value)); // remove all before value",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Removes range in tree order"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(set& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another set",
        "Arguments": "other: set to swap with",
        "Return Type": "void",
        "When to Use": "Exchange sets; optimize moves; swap-based algorithms",
        "When NOT to Use": "Different value types",
        "Example": "s1.swap(s2); swap(s1, s2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps tree pointers"
    },
    {
        "Category": "Modifiers",
        "Function": "extract (by iterator)",
        "Signature": "node_type extract(const_iterator position)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Removes and returns node handle at iterator",
        "Arguments": "position: iterator to element",
        "Return Type": "node_type (handle to extracted node)",
        "When to Use": "Move elements between sets; modify values; avoid reallocation",
        "When NOT to Use": "Just removing (use erase); don't need node",
        "Example": "auto nh = s1.extract(it); s2.insert(std::move(nh));",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++17",
        "Notes": "Enables value modification; move between sets without reallocation"
    },
    {
        "Category": "Modifiers",
        "Function": "extract (by value)",
        "Signature": "node_type extract(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Removes and returns node handle for value",
        "Arguments": "value: value of element to extract",
        "Return Type": "node_type (handle to extracted node, empty if not found)",
        "When to Use": "Move element to another set; modify value; splice operation",
        "When NOT to Use": "Just removing (use erase)",
        "Example": "auto nh = s1.extract(42); if(!nh.empty()) s2.insert(std::move(nh));",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++17",
        "Notes": "Returns empty node_type if value not found"
    },
    {
        "Category": "Modifiers",
        "Function": "merge",
        "Signature": "void merge(set& source)",
        "Time Complexity": "O(n log(size() + n))",
        "Space Complexity": "O(1)",
        "Description": "Splices nodes from source set; doesn't copy or move elements",
        "Arguments": "source: set to merge from",
        "Return Type": "void",
        "When to Use": "Merge sets efficiently; combine without copying; unique ownership",
        "When NOT to Use": "Want to keep source; need to handle duplicate values specially",
        "Example": "s1.merge(s2); // s2 may retain duplicate values",
        "Real World Frequency": 4,
        "DSA Training Frequency": 3,
        "C++ Version": "C++17",
        "Notes": "No allocation; source retains elements already in destination; very efficient"
    },
    
    # ==================== LOOKUP ====================
    {
        "Category": "Lookup",
        "Function": "count",
        "Signature": "size_type count(const value_type& value) const",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements with value (0 or 1 for set)",
        "Arguments": "value: value to search for",
        "Return Type": "size_type (0 or 1)",
        "When to Use": "Check existence; simple boolean check as count > 0",
        "When NOT to Use": "Need iterator (use find); C++20+ (use contains)",
        "Example": "if(s.count(42)) { cout << \"Found\"; }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Common for existence check; returns 0 or 1 for set"
    },
    {
        "Category": "Lookup",
        "Function": "find",
        "Signature": "iterator find(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Finds element with value",
        "Arguments": "value: value to search for",
        "Return Type": "iterator to element, or end() if not found",
        "When to Use": "Get iterator to element; check and use value; need position",
        "When NOT to Use": "Just checking existence (use contains/count)",
        "Example": "auto it = s.find(42); if(it != s.end()) { use(*it); }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Returns iterator; useful when you need position"
    },
    {
        "Category": "Lookup",
        "Function": "contains",
        "Signature": "bool contains(const value_type& value) const",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if value exists in set",
        "Arguments": "value: value to check",
        "Return Type": "bool",
        "When to Use": "Simple existence check; modern C++ code; readable",
        "When NOT to Use": "Need iterator (use find); C++17 and earlier (use count/find)",
        "Example": "if(s.contains(42)) { cout << \"Found\"; }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++20",
        "Notes": "Cleaner than count; modern addition; most readable"
    },
    {
        "Category": "Lookup",
        "Function": "lower_bound",
        "Signature": "iterator lower_bound(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element not less than value",
        "Arguments": "value: value to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find insertion point; ordered operations",
        "When NOT to Use": "Exact match only (use find)",
        "Example": "auto it = s.lower_bound(42); // first >= 42",
        "Real World Frequency": 7,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Very useful for range queries; returns end() if all < value"
    },
    {
        "Category": "Lookup",
        "Function": "upper_bound",
        "Signature": "iterator upper_bound(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element greater than value",
        "Arguments": "value: value to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find elements after value; ordered operations",
        "When NOT to Use": "Exact match (use find)",
        "Example": "auto it = s.upper_bound(42); // first > 42",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Pair with lower_bound for ranges; returns end() if all <= value"
    },
    {
        "Category": "Lookup",
        "Function": "equal_range",
        "Signature": "pair<iterator, iterator> equal_range(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns range of elements matching value [lower_bound, upper_bound)",
        "Arguments": "value: value to search for",
        "Return Type": "pair of iterators defining the range",
        "When to Use": "Get range in one call; multiset-style lookup",
        "When NOT to Use": "Set (range has at most 1 element); only need one bound",
        "Example": "auto [lo, hi] = s.equal_range(42);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "More useful for multiset; single log(n) search for both bounds"
    },
    
    # ==================== OBSERVERS ====================
    {
        "Category": "Observers",
        "Function": "key_comp",
        "Signature": "key_compare key_comp() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns comparison function object",
        "Arguments": "None",
        "Return Type": "key_compare (comparison function)",
        "When to Use": "Get comparator; custom sorting logic; algorithm interop",
        "When NOT to Use": "Normal usage; rarely needed",
        "Example": "auto comp = s.key_comp(); if(comp(a, b)) { }",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++98",
        "Notes": "Returns copy of comparison object; rarely used directly"
    },
    {
        "Category": "Observers",
        "Function": "value_comp",
        "Signature": "value_compare value_comp() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns comparison function object (same as key_comp for set)",
        "Arguments": "None",
        "Return Type": "value_compare (comparison function)",
        "When to Use": "Algorithm requirements; same as key_comp for set",
        "When NOT to Use": "Normal usage; use key_comp instead",
        "Example": "auto comp = s.value_comp(); if(comp(a, b)) { }",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Identical to key_comp for set; exists for API consistency"
    },
]


# ==============================================================================
# UNORDERED_SET CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
unordered_set_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "unordered_set()",
        "Signature": "unordered_set()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty unordered_set",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty set; will add elements later; most common constructor",
        "When NOT to Use": "Have initial values (use initializer_list)",
        "Example": "unordered_set<int> s;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "Hash table implementation; unordered; O(1) average operations; faster than set"
    },
    {
        "Category": "Construction",
        "Function": "unordered_set(size_type bucket_count)",
        "Signature": "unordered_set(size_type bucket_count, ...)",
        "Time Complexity": "O(bucket_count)",
        "Space Complexity": "O(bucket_count)",
        "Description": "Constructs empty set with at least specified bucket count",
        "Arguments": "bucket_count: minimum number of buckets",
        "Return Type": "N/A (constructor)",
        "When to Use": "Know approximate size; optimize performance; avoid rehashing",
        "When NOT to Use": "Unknown size; default is fine",
        "Example": "unordered_set<int> s(1000); // pre-allocate buckets",
        "Real World Frequency": 4,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Performance optimization; prevents rehashing"
    },
    {
        "Category": "Construction",
        "Function": "unordered_set(initializer_list)",
        "Signature": "unordered_set(initializer_list<value_type> init)",
        "Time Complexity": "O(n) average",
        "Space Complexity": "O(n)",
        "Description": "Constructs set from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases; small datasets",
        "When NOT to Use": "Large datasets; dynamic initialization",
        "Example": "unordered_set<int> s = {1, 2, 3, 4, 5};",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Automatically removes duplicates; unordered"
    },
    {
        "Category": "Construction",
        "Function": "unordered_set(Iterator first, Iterator last)",
        "Signature": "unordered_set(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n) average",
        "Space Complexity": "O(n)",
        "Description": "Constructs set from range",
        "Arguments": "first: iterator to beginning; last: iterator to end",
        "Return Type": "N/A (constructor)",
        "When to Use": "Remove duplicates from range; convert vector to set; filter data",
        "When NOT to Use": "Copy entire set (use copy constructor)",
        "Example": "unordered_set<int> s(v.begin(), v.end());",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Removes duplicates automatically; faster than set for construction"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element (arbitrary order)",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate elements; range operations (order doesn't matter)",
        "When NOT to Use": "Need sorted order (use set)",
        "Example": "for(auto it = s.begin(); it != s.end(); ++it) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Unordered iteration; forward iterator only"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing elements",
        "Example": "auto it = s.find(val); if(it != s.end()) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Past-the-end iterator; don't dereference"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if set is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input",
        "When NOT to Use": "Need size (use size())",
        "Example": "if(!s.empty()) { process(s); }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get count; size validation",
        "When NOT to Use": "Checking if empty (use empty())",
        "Example": "cout << s.size() << \" unique elements\";",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Constant time; cached value"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = s.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++11",
        "Notes": "Implementation defined"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset set; reuse container",
        "When NOT to Use": "Will delete set anyway",
        "Example": "s.clear();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Size becomes 0; doesn't change bucket count"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "pair<iterator, bool> insert(const value_type& value)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Inserts element if not already present",
        "Arguments": "value: element to insert",
        "Return Type": "pair<iterator, bool>",
        "When to Use": "Add unique elements; check duplicates; build set",
        "When NOT to Use": "Duplicates allowed (use multiset)",
        "Example": "auto [it, inserted] = s.insert(42);",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "Average O(1); much faster than set for insertion"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (range)",
        "Signature": "void insert(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n) average",
        "Space Complexity": "O(1)",
        "Description": "Inserts elements from range",
        "Arguments": "first, last: range of elements",
        "Return Type": "void",
        "When to Use": "Bulk insert; merge sets; remove duplicates",
        "When NOT to Use": "Single element",
        "Example": "s1.insert(s2.begin(), s2.end());",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Faster than set for bulk operations"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "pair<iterator, bool> emplace(Args&&... args)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place if not present",
        "Arguments": "args: arguments for constructor",
        "Return Type": "pair<iterator, bool>",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types (insert is fine)",
        "Example": "s.emplace(arg1, arg2);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; efficient"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by iterator)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1) average",
        "Space Complexity": "O(1)",
        "Description": "Removes element at iterator",
        "Arguments": "pos: iterator to element",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove during iteration",
        "When NOT to Use": "Have value only (use erase by value)",
        "Example": "for(auto it = s.begin(); it != s.end(); ) { if(cond) it = s.erase(it); else ++it; }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Average O(1); very fast"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by value)",
        "Signature": "size_type erase(const value_type& value)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Removes element with value",
        "Arguments": "value: value to remove",
        "Return Type": "size_type (0 or 1)",
        "When to Use": "Remove by value; simple deletion",
        "When NOT to Use": "During iteration (use iterator version)",
        "Example": "if(s.erase(42)) { cout << \"Removed\"; }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "Average O(1); most common erase"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(unordered_set& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another set",
        "Arguments": "other: set to swap with",
        "Return Type": "void",
        "When to Use": "Exchange sets; optimize moves",
        "When NOT to Use": "Different types",
        "Example": "s1.swap(s2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Constant time; swaps pointers"
    },
    
    # ==================== LOOKUP ====================
    {
        "Category": "Lookup",
        "Function": "count",
        "Signature": "size_type count(const value_type& value) const",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements with value (0 or 1)",
        "Arguments": "value: value to search",
        "Return Type": "size_type (0 or 1)",
        "When to Use": "Check existence; simple boolean",
        "When NOT to Use": "Need iterator (use find); C++20+ (use contains)",
        "Example": "if(s.count(42)) { cout << \"Found\"; }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "Average O(1); very fast existence check"
    },
    {
        "Category": "Lookup",
        "Function": "find",
        "Signature": "iterator find(const value_type& value)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Finds element with value",
        "Arguments": "value: value to search",
        "Return Type": "iterator to element or end()",
        "When to Use": "Get iterator; check and use value",
        "When NOT to Use": "Just checking existence (use contains/count)",
        "Example": "auto it = s.find(42); if(it != s.end()) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Average O(1); much faster than set::find"
    },
    {
        "Category": "Lookup",
        "Function": "contains",
        "Signature": "bool contains(const value_type& value) const",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Checks if value exists",
        "Arguments": "value: value to check",
        "Return Type": "bool",
        "When to Use": "Simple existence check; readable",
        "When NOT to Use": "Need iterator (use find); C++17 and earlier",
        "Example": "if(s.contains(42)) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++20",
        "Notes": "Cleaner than count; modern"
    },
    
    # ==================== BUCKET INTERFACE ====================
    {
        "Category": "Bucket Interface",
        "Function": "bucket_count",
        "Signature": "size_type bucket_count() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of buckets",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Debug hash distribution; performance analysis",
        "When NOT to Use": "Normal usage",
        "Example": "cout << s.bucket_count();",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Internal detail; useful for debugging"
    },
    {
        "Category": "Bucket Interface",
        "Function": "load_factor",
        "Signature": "float load_factor() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns average elements per bucket",
        "Arguments": "None",
        "Return Type": "float",
        "When to Use": "Analyze performance; check hash quality",
        "When NOT to Use": "Normal usage",
        "Example": "float lf = s.load_factor();",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "size() / bucket_count()"
    },
    {
        "Category": "Bucket Interface",
        "Function": "max_load_factor",
        "Signature": "float max_load_factor() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum load factor before rehash",
        "Arguments": "None",
        "Return Type": "float",
        "When to Use": "Understand rehashing behavior",
        "When NOT to Use": "Normal usage",
        "Example": "float max_lf = s.max_load_factor();",
        "Real World Frequency": 2,
        "DSA Training Frequency": 1,
        "C++ Version": "C++11",
        "Notes": "Triggers rehash when exceeded"
    },
    {
        "Category": "Bucket Interface",
        "Function": "rehash",
        "Signature": "void rehash(size_type count)",
        "Time Complexity": "O(n) average",
        "Space Complexity": "O(n)",
        "Description": "Sets number of buckets to at least count",
        "Arguments": "count: minimum bucket count",
        "Return Type": "void",
        "When to Use": "Optimize before bulk insert; control performance",
        "When NOT to Use": "Unknown size; default is fine",
        "Example": "s.rehash(1000);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Invalidates iterators; performance optimization"
    },
    {
        "Category": "Bucket Interface",
        "Function": "reserve",
        "Signature": "void reserve(size_type count)",
        "Time Complexity": "O(n) average",
        "Space Complexity": "O(n)",
        "Description": "Reserves space for at least count elements",
        "Arguments": "count: number of elements",
        "Return Type": "void",
        "When to Use": "Know final size; avoid rehashing",
        "When NOT to Use": "Unknown size",
        "Example": "s.reserve(10000);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Performance optimization; very useful"
    },
]


# ==============================================================================
# MULTISET CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
multiset_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "multiset()",
        "Signature": "multiset()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty multiset",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty multiset; allows duplicates unlike set",
        "When NOT to Use": "Need unique elements (use set)",
        "Example": "multiset<int> ms;",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Red-black tree; sorted; allows duplicates"
    },
    {
        "Category": "Construction",
        "Function": "multiset(initializer_list)",
        "Signature": "multiset(initializer_list<value_type> init)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs multiset from initializer list",
        "Arguments": "init: initializer list with values (can have duplicates)",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with values; duplicates allowed; test cases",
        "When NOT to Use": "Large datasets",
        "Example": "multiset<int> ms = {1, 2, 2, 3, 3, 3};",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Keeps duplicates; automatically sorted"
    },
    {
        "Category": "Construction",
        "Function": "multiset(Iterator first, Iterator last)",
        "Signature": "multiset(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs multiset from range",
        "Arguments": "first, last: range of values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert range to sorted multiset; keep duplicates",
        "When NOT to Use": "Need unique elements (use set)",
        "Example": "multiset<int> ms(v.begin(), v.end());",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Keeps duplicates; sorts elements"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element (smallest)",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate in sorted order; includes all duplicates",
        "When NOT to Use": "Need specific value (use find)",
        "Example": "for(auto it = ms.begin(); it != ms.end(); ++it) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Sorted order with duplicates"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination",
        "When NOT to Use": "Accessing elements",
        "Example": "auto it = ms.find(val); if(it != ms.end()) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if multiset is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access",
        "When NOT to Use": "Need size",
        "Example": "if(!ms.empty()) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns total number of elements (including duplicates)",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get count including duplicates",
        "When NOT to Use": "Checking if empty",
        "Example": "cout << ms.size(); // total elements",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Includes all duplicates"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset multiset",
        "When NOT to Use": "Will delete anyway",
        "Example": "ms.clear();",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Size becomes 0"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "iterator insert(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element (always succeeds, allows duplicates)",
        "Arguments": "value: element to insert",
        "Return Type": "iterator to inserted element",
        "When to Use": "Add elements; duplicates allowed; frequency counting",
        "When NOT to Use": "Need unique elements (use set)",
        "Example": "ms.insert(42); ms.insert(42); // both succeed",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Always inserts; returns iterator not pair (unlike set)"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (range)",
        "Signature": "void insert(InputIterator first, InputIterator last)",
        "Time Complexity": "O(m log(n+m)) where m = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Inserts all elements from range",
        "Arguments": "first, last: range of elements",
        "Return Type": "void",
        "When to Use": "Bulk insert; keep all duplicates",
        "When NOT to Use": "Single element",
        "Example": "ms.insert(v.begin(), v.end());",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Keeps all duplicates"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "iterator emplace(Args&&... args)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place (always succeeds)",
        "Arguments": "args: arguments for constructor",
        "Return Type": "iterator to inserted element",
        "When to Use": "Construct complex objects; duplicates allowed",
        "When NOT to Use": "Simple types",
        "Example": "ms.emplace(arg1, arg2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Always inserts; perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by iterator)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Removes element at iterator",
        "Arguments": "pos: iterator to element",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove specific occurrence; during iteration",
        "When NOT to Use": "Remove all occurrences (use erase by value)",
        "Example": "auto it = ms.find(42); ms.erase(it); // removes one occurrence",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Removes single element only"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by value)",
        "Signature": "size_type erase(const value_type& value)",
        "Time Complexity": "O(log n + count)",
        "Space Complexity": "O(1)",
        "Description": "Removes ALL elements with value",
        "Arguments": "value: value to remove",
        "Return Type": "size_type (number removed)",
        "When to Use": "Remove all occurrences of value",
        "When NOT to Use": "Remove single occurrence (use iterator version)",
        "Example": "size_t removed = ms.erase(42); // removes all 42s",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Removes ALL occurrences; returns count removed"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(multiset& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another multiset",
        "Arguments": "other: multiset to swap with",
        "Return Type": "void",
        "When to Use": "Exchange multisets",
        "When NOT to Use": "Different types",
        "Example": "ms1.swap(ms2);",
        "Real World Frequency": 4,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Constant time"
    },
    
    # ==================== LOOKUP ====================
    {
        "Category": "Lookup",
        "Function": "count",
        "Signature": "size_type count(const value_type& value) const",
        "Time Complexity": "O(log n + count)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements with value",
        "Arguments": "value: value to count",
        "Return Type": "size_type (can be > 1)",
        "When to Use": "Count occurrences; frequency of value",
        "When NOT to Use": "Just existence check (use contains/find)",
        "Example": "cout << ms.count(42) << \" occurrences\";",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Returns actual count; can be > 1 unlike set"
    },
    {
        "Category": "Lookup",
        "Function": "find",
        "Signature": "iterator find(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Finds one element with value",
        "Arguments": "value: value to search",
        "Return Type": "iterator to one occurrence or end()",
        "When to Use": "Get iterator to any occurrence",
        "When NOT to Use": "Need all occurrences (use equal_range)",
        "Example": "auto it = ms.find(42); // one occurrence",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Returns iterator to any occurrence"
    },
    {
        "Category": "Lookup",
        "Function": "contains",
        "Signature": "bool contains(const value_type& value) const",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if value exists",
        "Arguments": "value: value to check",
        "Return Type": "bool",
        "When to Use": "Existence check; readable",
        "When NOT to Use": "Need count (use count); C++17 and earlier",
        "Example": "if(ms.contains(42)) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++20",
        "Notes": "Modern; cleaner than count > 0"
    },
    {
        "Category": "Lookup",
        "Function": "lower_bound",
        "Signature": "iterator lower_bound(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element >= value",
        "Arguments": "value: value to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find start of duplicates",
        "When NOT to Use": "Exact match only",
        "Example": "auto it = ms.lower_bound(42); // first >= 42",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "First of potentially many equal elements"
    },
    {
        "Category": "Lookup",
        "Function": "upper_bound",
        "Signature": "iterator upper_bound(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element > value",
        "Arguments": "value: value to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find end of duplicates",
        "When NOT to Use": "Exact match",
        "Example": "auto it = ms.upper_bound(42); // first > 42",
        "Real World Frequency": 6,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Past last equal element"
    },
    {
        "Category": "Lookup",
        "Function": "equal_range",
        "Signature": "pair<iterator, iterator> equal_range(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns range of ALL elements with value",
        "Arguments": "value: value to search",
        "Return Type": "pair of iterators [lower_bound, upper_bound)",
        "When to Use": "Get all occurrences; iterate duplicates; count range",
        "When NOT to Use": "Single occurrence; just count",
        "Example": "auto [lo, hi] = ms.equal_range(42); // all 42s\nfor(auto it = lo; it != hi; ++it) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Very useful for multiset; returns all duplicates"
    },
]


# ==============================================================================
# MULTIMAP CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
multimap_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "multimap()",
        "Signature": "multimap()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty multimap",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty multimap; allows duplicate keys unlike map",
        "When NOT to Use": "Need unique keys (use map)",
        "Example": "multimap<string, int> mm;",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Red-black tree; sorted by key; duplicate keys allowed"
    },
    {
        "Category": "Construction",
        "Function": "multimap(initializer_list)",
        "Signature": "multimap(initializer_list<value_type> init)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs multimap from initializer list",
        "Arguments": "init: initializer list of {key, value} pairs",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with duplicate keys; test cases",
        "When NOT to Use": "Need unique keys",
        "Example": "multimap<string, int> mm = {{\"A\", 1}, {\"A\", 2}, {\"B\", 3}};",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++11",
        "Notes": "Allows duplicate keys; sorted"
    },
    {
        "Category": "Construction",
        "Function": "multimap(Iterator first, Iterator last)",
        "Signature": "multimap(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs multimap from range",
        "Arguments": "first, last: range of pairs",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert range; keep duplicate keys",
        "When NOT to Use": "Need unique keys",
        "Example": "multimap<int, string> mm(v.begin(), v.end());",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Keeps duplicate keys"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "NOTE: No operator[]",
        "Signature": "N/A - operator[] does not exist for multimap",
        "Time Complexity": "N/A",
        "Space Complexity": "N/A",
        "Description": "Multimap has no operator[] (ambiguous with duplicate keys)",
        "Arguments": "N/A",
        "Return Type": "N/A",
        "When to Use": "N/A - use find() or equal_range() instead",
        "When NOT to Use": "Always - not available for multimap",
        "Example": "// mm[key] = value; // ERROR! Not available\nauto it = mm.find(key); // Use this instead",
        "Real World Frequency": 0,
        "DSA Training Frequency": 0,
        "C++ Version": "N/A",
        "Notes": "Key difference from map; use find/equal_range instead"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element (smallest key)",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate in sorted key order; includes duplicates",
        "When NOT to Use": "Need specific key (use find)",
        "Example": "for(auto it = mm.begin(); it != mm.end(); ++it) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Sorted by key; duplicate keys consecutive"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination",
        "When NOT to Use": "Accessing elements",
        "Example": "auto it = mm.find(key); if(it != mm.end()) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if multimap is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access",
        "When NOT to Use": "Need size",
        "Example": "if(!mm.empty()) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns total number of pairs (including duplicates)",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get total count including duplicate keys",
        "When NOT to Use": "Checking if empty",
        "Example": "cout << mm.size(); // total pairs",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Includes all pairs with duplicate keys"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset multimap",
        "When NOT to Use": "Will delete anyway",
        "Example": "mm.clear();",
        "Real World Frequency": 5,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Size becomes 0"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "iterator insert(const value_type& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element (always succeeds, allows duplicate keys)",
        "Arguments": "value: pair<key, value> to insert",
        "Return Type": "iterator to inserted element",
        "When to Use": "Add pairs; duplicate keys allowed; one-to-many mappings",
        "When NOT to Use": "Need unique keys (use map)",
        "Example": "mm.insert({\"key\", 1}); mm.insert({\"key\", 2}); // both succeed",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Always inserts; returns iterator not pair (unlike map)"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (range)",
        "Signature": "void insert(InputIterator first, InputIterator last)",
        "Time Complexity": "O(m log(n+m))",
        "Space Complexity": "O(1)",
        "Description": "Inserts all elements from range",
        "Arguments": "first, last: range of pairs",
        "Return Type": "void",
        "When to Use": "Bulk insert; keep all duplicate keys",
        "When NOT to Use": "Single element",
        "Example": "mm1.insert(mm2.begin(), mm2.end());",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Keeps all duplicate keys"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "iterator emplace(Args&&... args)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place (always succeeds)",
        "Arguments": "args: arguments for value_type constructor",
        "Return Type": "iterator to inserted element",
        "When to Use": "Construct pairs in-place; duplicate keys allowed",
        "When NOT to Use": "Simple types",
        "Example": "mm.emplace(key, value);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Always inserts; perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by iterator)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Removes element at iterator",
        "Arguments": "pos: iterator to element",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove specific pair; during iteration",
        "When NOT to Use": "Remove all with key (use erase by key)",
        "Example": "auto it = mm.find(key); mm.erase(it); // removes one pair",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Removes single pair only"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (by key)",
        "Signature": "size_type erase(const key_type& key)",
        "Time Complexity": "O(log n + count)",
        "Space Complexity": "O(1)",
        "Description": "Removes ALL elements with key",
        "Arguments": "key: key to remove",
        "Return Type": "size_type (number removed)",
        "When to Use": "Remove all pairs with key",
        "When NOT to Use": "Remove single pair (use iterator version)",
        "Example": "size_t removed = mm.erase(\"key\"); // removes all with this key",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Removes ALL pairs with key; returns count"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(multimap& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another multimap",
        "Arguments": "other: multimap to swap with",
        "Return Type": "void",
        "When to Use": "Exchange multimaps",
        "When NOT to Use": "Different types",
        "Example": "mm1.swap(mm2);",
        "Real World Frequency": 4,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Constant time"
    },
    
    # ==================== LOOKUP ====================
    {
        "Category": "Lookup",
        "Function": "count",
        "Signature": "size_type count(const key_type& key) const",
        "Time Complexity": "O(log n + count)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements with key",
        "Arguments": "key: key to count",
        "Return Type": "size_type (can be > 1)",
        "When to Use": "Count occurrences of key; how many values for key",
        "When NOT to Use": "Just existence (use contains/find)",
        "Example": "cout << mm.count(\"key\") << \" values for this key\";",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Returns actual count; can be > 1"
    },
    {
        "Category": "Lookup",
        "Function": "find",
        "Signature": "iterator find(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Finds one element with key",
        "Arguments": "key: key to search",
        "Return Type": "iterator to one occurrence or end()",
        "When to Use": "Get iterator to any occurrence of key",
        "When NOT to Use": "Need all values (use equal_range)",
        "Example": "auto it = mm.find(key); // one occurrence",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Returns iterator to any one pair with key"
    },
    {
        "Category": "Lookup",
        "Function": "contains",
        "Signature": "bool contains(const key_type& key) const",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if key exists",
        "Arguments": "key: key to check",
        "Return Type": "bool",
        "When to Use": "Existence check; readable",
        "When NOT to Use": "Need count (use count); C++17 and earlier",
        "Example": "if(mm.contains(key)) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++20",
        "Notes": "Modern; cleaner than count > 0"
    },
    {
        "Category": "Lookup",
        "Function": "lower_bound",
        "Signature": "iterator lower_bound(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element with key >= given key",
        "Arguments": "key: key to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find start of key range",
        "When NOT to Use": "Exact match only",
        "Example": "auto it = mm.lower_bound(key);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "First of potentially many with same key"
    },
    {
        "Category": "Lookup",
        "Function": "upper_bound",
        "Signature": "iterator upper_bound(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element with key > given key",
        "Arguments": "key: key to compare",
        "Return Type": "iterator",
        "When to Use": "Range queries; find end of key range",
        "When NOT to Use": "Exact match",
        "Example": "auto it = mm.upper_bound(key);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Past last with same key"
    },
    {
        "Category": "Lookup",
        "Function": "equal_range",
        "Signature": "pair<iterator, iterator> equal_range(const key_type& key)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Returns range of ALL elements with key",
        "Arguments": "key: key to search",
        "Return Type": "pair of iterators [lower_bound, upper_bound)",
        "When to Use": "Get all values for key; iterate all pairs with same key",
        "When NOT to Use": "Single pair; just count",
        "Example": "auto [lo, hi] = mm.equal_range(key);\nfor(auto it = lo; it != hi; ++it) { cout << it->second; }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Essential for multimap; gets all values for a key"
    },
]


# ==============================================================================
# DEQUE CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
deque_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "deque()",
        "Signature": "deque()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty deque",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty deque; double-ended queue; fast insertion at both ends",
        "When NOT to Use": "Only need single-end access (use vector); need contiguous memory",
        "Example": "deque<int> dq;",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Double-ended queue; O(1) push/pop at both ends; non-contiguous memory"
    },
    {
        "Category": "Construction",
        "Function": "deque(size_type count, const T& value)",
        "Signature": "deque(size_type count, const T& value = T())",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs deque with count copies of value",
        "Arguments": "count: number of elements; value: value to copy",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with specific size and value",
        "When NOT to Use": "Empty deque (use default constructor)",
        "Example": "deque<int> dq(10, 42); // 10 elements with value 42",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Creates count elements"
    },
    {
        "Category": "Construction",
        "Function": "deque(initializer_list)",
        "Signature": "deque(initializer_list<T> init)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs deque from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases",
        "When NOT to Use": "Large datasets",
        "Example": "deque<int> dq = {1, 2, 3, 4, 5};",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Modern syntax; clean initialization"
    },
    {
        "Category": "Construction",
        "Function": "deque(Iterator first, Iterator last)",
        "Signature": "deque(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs deque from range",
        "Arguments": "first, last: range of elements",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert range to deque",
        "When NOT to Use": "Copy entire deque (use copy constructor)",
        "Example": "deque<int> dq(v.begin(), v.end());",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Copies elements from range"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "operator[]",
        "Signature": "reference operator[](size_type pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access element at index (no bounds checking)",
        "Arguments": "pos: index of element",
        "Return Type": "reference to element",
        "When to Use": "Fast access; valid index guaranteed",
        "When NOT to Use": "Index might be invalid (use at())",
        "Example": "dq[0] = 42; int x = dq[2];",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "No bounds checking; undefined behavior if out of range"
    },
    {
        "Category": "Element Access",
        "Function": "at",
        "Signature": "reference at(size_type pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access element at index with bounds checking",
        "Arguments": "pos: index of element",
        "Return Type": "reference to element",
        "When to Use": "Safe access; want exception on invalid index",
        "When NOT to Use": "Performance critical; index guaranteed valid",
        "Example": "try { dq.at(100) = 5; } catch(out_of_range&) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Throws out_of_range if invalid; safer than []"
    },
    {
        "Category": "Element Access",
        "Function": "front",
        "Signature": "reference front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access first element",
        "Arguments": "None",
        "Return Type": "reference to first element",
        "When to Use": "Access first element; deque operations",
        "When NOT to Use": "Deque might be empty",
        "Example": "int first = dq.front();",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; check with empty() first"
    },
    {
        "Category": "Element Access",
        "Function": "back",
        "Signature": "reference back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access last element",
        "Arguments": "None",
        "Return Type": "reference to last element",
        "When to Use": "Access last element; deque operations",
        "When NOT to Use": "Deque might be empty",
        "Example": "int last = dq.back();",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; check with empty() first"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate elements; range operations",
        "When NOT to Use": "Direct index access sufficient",
        "Example": "for(auto it = dq.begin(); it != dq.end(); ++it) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Random access iterator"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing elements",
        "Example": "auto it = find(dq.begin(), dq.end(), value);",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if deque is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input",
        "When NOT to Use": "Need size",
        "Example": "if(!dq.empty()) { int x = dq.front(); }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get count; size validation",
        "When NOT to Use": "Checking if empty",
        "Example": "cout << dq.size() << \" elements\";",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Constant time"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = dq.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Implementation defined"
    },
    {
        "Category": "Capacity",
        "Function": "shrink_to_fit",
        "Signature": "void shrink_to_fit()",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Requests removal of unused capacity",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reduce memory usage; finished growing deque",
        "When NOT to Use": "Will add more elements soon",
        "Example": "dq.shrink_to_fit();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Non-binding request; may reduce memory"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset deque; reuse container",
        "When NOT to Use": "Will delete deque anyway",
        "Example": "dq.clear();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Size becomes 0; invalidates iterators"
    },
    {
        "Category": "Modifiers",
        "Function": "push_back",
        "Signature": "void push_back(const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1) amortized",
        "Description": "Adds element to end",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add to end; build deque; queue operations",
        "When NOT to Use": "Need sorted order; need to add at front (use push_front)",
        "Example": "dq.push_back(42);",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "O(1) amortized; key feature of deque"
    },
    {
        "Category": "Modifiers",
        "Function": "push_front",
        "Signature": "void push_front(const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1) amortized",
        "Description": "Adds element to beginning",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add to front; deque operations; reverse building",
        "When NOT to Use": "Vector sufficient (use vector)",
        "Example": "dq.push_front(42);",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "O(1) amortized; major advantage over vector"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_back",
        "Signature": "void pop_back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes last element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove from end; stack/queue operations",
        "When NOT to Use": "Deque might be empty",
        "Example": "if(!dq.empty()) dq.pop_back();",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; doesn't return value"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_front",
        "Signature": "void pop_front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes first element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove from front; queue operations; BFS",
        "When NOT to Use": "Deque might be empty",
        "Example": "if(!dq.empty()) dq.pop_front();",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "O(1); major advantage over vector"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_back",
        "Signature": "void emplace_back(Args&&... args)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place at end",
        "Arguments": "args: arguments for constructor",
        "Return Type": "void",
        "When to Use": "Construct complex objects at end; avoid copies",
        "When NOT to Use": "Simple types (push_back is fine)",
        "Example": "dq.emplace_back(arg1, arg2, arg3);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; efficient"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_front",
        "Signature": "void emplace_front(Args&&... args)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place at beginning",
        "Arguments": "args: arguments for constructor",
        "Return Type": "void",
        "When to Use": "Construct complex objects at front; avoid copies",
        "When NOT to Use": "Simple types (push_front is fine)",
        "Example": "dq.emplace_front(arg1, arg2, arg3);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; efficient"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "iterator insert(const_iterator pos, const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element before position",
        "Arguments": "pos: iterator before which to insert; value: element to insert",
        "Return Type": "iterator to inserted element",
        "When to Use": "Insert at specific position",
        "When NOT to Use": "Insert at ends (use push_front/push_back); frequent middle inserts (use list)",
        "Example": "auto it = dq.insert(dq.begin() + 2, 42);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "O(n) linear; inefficient for middle inserts"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (single element)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes element at position",
        "Arguments": "pos: iterator to element",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove at specific position",
        "When NOT to Use": "Remove from ends (use pop_front/pop_back); frequent middle erases (use list)",
        "Example": "auto it = dq.erase(dq.begin() + 2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "O(n) linear; inefficient for middle erases"
    },
    {
        "Category": "Modifiers",
        "Function": "resize",
        "Signature": "void resize(size_type count)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Resizes deque to contain count elements",
        "Arguments": "count: new size",
        "Return Type": "void",
        "When to Use": "Change size; pre-allocate; trim excess",
        "When NOT to Use": "Just adding elements (use push_back)",
        "Example": "dq.resize(100); dq.resize(50);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Adds default-constructed or removes elements"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(deque& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another deque",
        "Arguments": "other: deque to swap with",
        "Return Type": "void",
        "When to Use": "Exchange deques; optimize moves",
        "When NOT to Use": "Different types",
        "Example": "dq1.swap(dq2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps pointers"
    },
]


# ==============================================================================
# LIST CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
list_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "list()",
        "Signature": "list()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty doubly-linked list",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty list; frequent insertions/deletions anywhere; no random access needed",
        "When NOT to Use": "Need random access (use vector/deque); cache-unfriendly",
        "Example": "list<int> lst;",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Doubly-linked list; O(1) insert/erase anywhere; no random access"
    },
    {
        "Category": "Construction",
        "Function": "list(size_type count, const T& value)",
        "Signature": "list(size_type count, const T& value = T())",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs list with count copies of value",
        "Arguments": "count: number of elements; value: value to copy",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with specific size and value",
        "When NOT to Use": "Empty list (use default constructor)",
        "Example": "list<int> lst(10, 42); // 10 elements with value 42",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Creates count nodes"
    },
    {
        "Category": "Construction",
        "Function": "list(initializer_list)",
        "Signature": "list(initializer_list<T> init)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs list from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases",
        "When NOT to Use": "Large datasets",
        "Example": "list<int> lst = {1, 2, 3, 4, 5};",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Modern syntax; clean initialization"
    },
    {
        "Category": "Construction",
        "Function": "list(Iterator first, Iterator last)",
        "Signature": "list(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs list from range",
        "Arguments": "first, last: range of elements",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert range to list",
        "When NOT to Use": "Copy entire list (use copy constructor)",
        "Example": "list<int> lst(v.begin(), v.end());",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Copies elements from range"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "front",
        "Signature": "reference front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access first element",
        "Arguments": "None",
        "Return Type": "reference to first element",
        "When to Use": "Access first element; list operations",
        "When NOT to Use": "List might be empty",
        "Example": "int first = lst.front();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; check with empty() first"
    },
    {
        "Category": "Element Access",
        "Function": "back",
        "Signature": "reference back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access last element",
        "Arguments": "None",
        "Return Type": "reference to last element",
        "When to Use": "Access last element; list operations",
        "When NOT to Use": "List might be empty",
        "Example": "int last = lst.back();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; check with empty() first"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate elements; range operations",
        "When NOT to Use": "Need random access",
        "Example": "for(auto it = lst.begin(); it != lst.end(); ++it) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Bidirectional iterator; no random access"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing elements",
        "Example": "auto it = find(lst.begin(), lst.end(), value);",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Past-the-end iterator"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if list is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input",
        "When NOT to Use": "Need size",
        "Example": "if(!lst.empty()) { int x = lst.front(); }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get count; size validation",
        "When NOT to Use": "Checking if empty",
        "Example": "cout << lst.size() << \" elements\";",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Constant time in C++11+; was O(n) in C++98"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = lst.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++98",
        "Notes": "Implementation defined"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset list; reuse container",
        "When NOT to Use": "Will delete list anyway",
        "Example": "lst.clear();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Size becomes 0; frees all nodes"
    },
    {
        "Category": "Modifiers",
        "Function": "push_back",
        "Signature": "void push_back(const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Adds element to end",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add to end; build list",
        "When NOT to Use": "Need sorted order",
        "Example": "lst.push_back(42);",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "O(1) always; no reallocation"
    },
    {
        "Category": "Modifiers",
        "Function": "push_front",
        "Signature": "void push_front(const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Adds element to beginning",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add to front; reverse building",
        "When NOT to Use": "Vector/deque sufficient",
        "Example": "lst.push_front(42);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "O(1) always; no reallocation"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_back",
        "Signature": "void pop_back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes last element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove from end",
        "When NOT to Use": "List might be empty",
        "Example": "if(!lst.empty()) lst.pop_back();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; doesn't return value"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_front",
        "Signature": "void pop_front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes first element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove from front; queue operations",
        "When NOT to Use": "List might be empty",
        "Example": "if(!lst.empty()) lst.pop_front();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; O(1) always"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (single element)",
        "Signature": "iterator insert(const_iterator pos, const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element before position",
        "Arguments": "pos: iterator before which to insert; value: element to insert",
        "Return Type": "iterator to inserted element",
        "When to Use": "Insert at specific position; main advantage of list",
        "When NOT to Use": "Insert at ends (use push_front/push_back)",
        "Example": "auto it = lst.insert(it_pos, 42);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "O(1)! Key advantage over vector/deque"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "iterator emplace(const_iterator pos, Args&&... args)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place at position",
        "Arguments": "pos: iterator before which to emplace; args: constructor arguments",
        "Return Type": "iterator to inserted element",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types (insert is fine)",
        "Example": "auto it = lst.emplace(it_pos, arg1, arg2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "O(1); perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (single element)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes element at position",
        "Arguments": "pos: iterator to element",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove at specific position; main advantage of list",
        "When NOT to Use": "Remove from ends (use pop_front/pop_back)",
        "Example": "auto it = lst.erase(it_pos);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "O(1)! Key advantage over vector/deque"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (range)",
        "Signature": "iterator erase(const_iterator first, const_iterator last)",
        "Time Complexity": "O(n) where n = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Removes range of elements",
        "Arguments": "first, last: range to remove",
        "Return Type": "iterator following last removed element",
        "When to Use": "Remove multiple consecutive elements",
        "When NOT to Use": "Single element (use single-element erase)",
        "Example": "auto it = lst.erase(lst.begin(), it_end);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "O(n) but each node removal is O(1)"
    },
    {
        "Category": "Modifiers",
        "Function": "resize",
        "Signature": "void resize(size_type count)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Resizes list to contain count elements",
        "Arguments": "count: new size",
        "Return Type": "void",
        "When to Use": "Change size; pre-allocate; trim excess",
        "When NOT to Use": "Just adding elements (use push_back)",
        "Example": "lst.resize(100); lst.resize(50);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Adds default-constructed or removes elements"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(list& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another list",
        "Arguments": "other: list to swap with",
        "Return Type": "void",
        "When to Use": "Exchange lists; optimize moves",
        "When NOT to Use": "Different types",
        "Example": "lst1.swap(lst2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps pointers"
    },
    
    # ==================== OPERATIONS ====================
    {
        "Category": "Operations",
        "Function": "merge",
        "Signature": "void merge(list& other)",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1)",
        "Description": "Merges two sorted lists",
        "Arguments": "other: sorted list to merge",
        "Return Type": "void",
        "When to Use": "Merge sorted lists; maintain sorted order",
        "When NOT to Use": "Lists not sorted",
        "Example": "lst1.merge(lst2); // both must be sorted",
        "Real World Frequency": 4,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Assumes both sorted; O(n+m); stable"
    },
    {
        "Category": "Operations",
        "Function": "splice (entire list)",
        "Signature": "void splice(const_iterator pos, list& other)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Transfers all elements from other to this list",
        "Arguments": "pos: position before which to insert; other: list to transfer from",
        "Return Type": "void",
        "When to Use": "Move entire list; O(1) transfer; unique to list",
        "When NOT to Use": "Partial transfer (use range splice)",
        "Example": "lst1.splice(lst1.begin(), lst2); // moves all from lst2",
        "Real World Frequency": 5,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "O(1)! Just relinks pointers; powerful operation"
    },
    {
        "Category": "Operations",
        "Function": "splice (single element)",
        "Signature": "void splice(const_iterator pos, list& other, const_iterator it)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Transfers single element from other to this list",
        "Arguments": "pos: position; other: source list; it: element to transfer",
        "Return Type": "void",
        "When to Use": "Move single element; O(1) transfer",
        "When NOT to Use": "Multiple elements (use range splice)",
        "Example": "lst1.splice(lst1.begin(), lst2, it);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "O(1)! Relinks pointers"
    },
    {
        "Category": "Operations",
        "Function": "remove",
        "Signature": "size_type remove(const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements equal to value",
        "Arguments": "value: value to remove",
        "Return Type": "size_type (count removed - C++20)",
        "When to Use": "Remove all occurrences of value",
        "When NOT to Use": "Remove by condition (use remove_if)",
        "Example": "lst.remove(42); // removes all 42s",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "O(n) linear scan; returns count in C++20+"
    },
    {
        "Category": "Operations",
        "Function": "remove_if",
        "Signature": "size_type remove_if(UnaryPredicate pred)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements satisfying predicate",
        "Arguments": "pred: unary predicate function",
        "Return Type": "size_type (count removed - C++20)",
        "When to Use": "Remove by condition; filter list",
        "When NOT to Use": "Specific value (use remove)",
        "Example": "lst.remove_if([](int x) { return x % 2 == 0; });",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Very useful; returns count in C++20+"
    },
    {
        "Category": "Operations",
        "Function": "reverse",
        "Signature": "void reverse() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Reverses the order of elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reverse list; in-place reversal",
        "When NOT to Use": "Need copy (use constructor with reverse iterators)",
        "Example": "lst.reverse();",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "O(n) but just relinks pointers; efficient"
    },
    {
        "Category": "Operations",
        "Function": "unique",
        "Signature": "size_type unique()",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes consecutive duplicate elements",
        "Arguments": "None",
        "Return Type": "size_type (count removed - C++20)",
        "When to Use": "Remove consecutive duplicates; after sorting",
        "When NOT to Use": "Non-consecutive duplicates (sort first)",
        "Example": "lst.sort(); lst.unique(); // removes all duplicates",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Only consecutive; usually used after sort"
    },
    {
        "Category": "Operations",
        "Function": "sort",
        "Signature": "void sort()",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(1)",
        "Description": "Sorts elements in ascending order",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Sort list; maintain order; stable sort",
        "When NOT to Use": "Vector/deque sufficient (use std::sort)",
        "Example": "lst.sort(); // stable sort",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "O(n log n); stable; member function (can't use std::sort on list)"
    },
]


# ==============================================================================
# FORWARD_LIST CONTAINER - ALL MEMBER FUNCTIONS
# ==============================================================================
forward_list_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "forward_list()",
        "Signature": "forward_list()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty singly-linked list",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty forward list; minimize memory; only forward iteration needed",
        "When NOT to Use": "Need bidirectional iteration (use list); need back() access",
        "Example": "forward_list<int> fl;",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Singly-linked list; smallest memory overhead; no size() in C++11-17"
    },
    {
        "Category": "Construction",
        "Function": "forward_list(size_type count, const T& value)",
        "Signature": "forward_list(size_type count, const T& value = T())",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs forward_list with count copies of value",
        "Arguments": "count: number of elements; value: value to copy",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with specific size and value",
        "When NOT to Use": "Empty list (use default constructor)",
        "Example": "forward_list<int> fl(10, 42);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Creates count nodes"
    },
    {
        "Category": "Construction",
        "Function": "forward_list(initializer_list)",
        "Signature": "forward_list(initializer_list<T> init)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs forward_list from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases",
        "When NOT to Use": "Large datasets",
        "Example": "forward_list<int> fl = {1, 2, 3, 4, 5};",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Modern syntax"
    },
    {
        "Category": "Construction",
        "Function": "forward_list(Iterator first, Iterator last)",
        "Signature": "forward_list(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs forward_list from range",
        "Arguments": "first, last: range of elements",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert range to forward_list",
        "When NOT to Use": "Copy entire list (use copy constructor)",
        "Example": "forward_list<int> fl(v.begin(), v.end());",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Copies elements from range"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "front",
        "Signature": "reference front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access first element",
        "Arguments": "None",
        "Return Type": "reference to first element",
        "When to Use": "Access first element; forward_list operations",
        "When NOT to Use": "List might be empty",
        "Example": "int first = fl.front();",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Undefined if empty; NO back() - singly-linked"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "before_begin",
        "Signature": "iterator before_begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to before first element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Insert at beginning; unique to forward_list",
        "When NOT to Use": "Normal iteration (use begin)",
        "Example": "fl.insert_after(fl.before_begin(), 42);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Unique to forward_list; enables insert at front"
    },
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate elements; range operations",
        "When NOT to Use": "Need bidirectional iteration",
        "Example": "for(auto it = fl.begin(); it != fl.end(); ++it) { }",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Forward iterator only; no operator--"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing elements",
        "Example": "auto it = find(fl.begin(), fl.end(), value);",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Past-the-end iterator"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if forward_list is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input",
        "When NOT to Use": "Need count (no size() until C++20)",
        "Example": "if(!fl.empty()) { int x = fl.front(); }",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "No size() in C++11-17; added in C++20"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = fl.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++11",
        "Notes": "Implementation defined"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset forward_list; reuse container",
        "When NOT to Use": "Will delete anyway",
        "Example": "fl.clear();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Frees all nodes"
    },
    {
        "Category": "Modifiers",
        "Function": "push_front",
        "Signature": "void push_front(const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Adds element to beginning",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add to front; build forward_list",
        "When NOT to Use": "Need push_back (no push_back - singly-linked)",
        "Example": "fl.push_front(42);",
        "Real World Frequency": 4,
        "DSA Training Frequency": 6,
        "C++ Version": "C++11",
        "Notes": "O(1); NO push_back - singly-linked"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_front",
        "Signature": "void pop_front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes first element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove from front",
        "When NOT to Use": "List might be empty",
        "Example": "if(!fl.empty()) fl.pop_front();",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Undefined if empty; NO pop_back"
    },
    {
        "Category": "Modifiers",
        "Function": "insert_after (single element)",
        "Signature": "iterator insert_after(const_iterator pos, const T& value)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element AFTER position",
        "Arguments": "pos: iterator after which to insert; value: element to insert",
        "Return Type": "iterator to inserted element",
        "When to Use": "Insert after position; unique to forward_list",
        "When NOT to Use": "Need insert before (use before_begin for front)",
        "Example": "auto it = fl.insert_after(fl.begin(), 42);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "O(1); AFTER not before (singly-linked limitation)"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_front",
        "Signature": "void emplace_front(Args&&... args)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place at beginning",
        "Arguments": "args: arguments for constructor",
        "Return Type": "void",
        "When to Use": "Construct complex objects at front; avoid copies",
        "When NOT to Use": "Simple types (push_front is fine)",
        "Example": "fl.emplace_front(arg1, arg2);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace_after",
        "Signature": "iterator emplace_after(const_iterator pos, Args&&... args)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place AFTER position",
        "Arguments": "pos: iterator after which to emplace; args: constructor arguments",
        "Return Type": "iterator to inserted element",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types",
        "Example": "auto it = fl.emplace_after(fl.begin(), arg1, arg2);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "O(1); perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "erase_after (single element)",
        "Signature": "iterator erase_after(const_iterator pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes element AFTER position",
        "Arguments": "pos: iterator before element to erase",
        "Return Type": "iterator following erased element",
        "When to Use": "Remove element after position",
        "When NOT to Use": "Remove at position (impossible in singly-linked)",
        "Example": "auto it = fl.erase_after(fl.before_begin()); // removes first",
        "Real World Frequency": 3,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "O(1); AFTER not at (singly-linked limitation)"
    },
    {
        "Category": "Modifiers",
        "Function": "erase_after (range)",
        "Signature": "iterator erase_after(const_iterator first, const_iterator last)",
        "Time Complexity": "O(n) where n = distance(first, last)",
        "Space Complexity": "O(1)",
        "Description": "Removes range AFTER first up to last",
        "Arguments": "first: iterator before range; last: end of range",
        "Return Type": "iterator following last erased element",
        "When to Use": "Remove multiple consecutive elements",
        "When NOT to Use": "Single element",
        "Example": "fl.erase_after(fl.before_begin(), fl.end()); // clears all",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Erases (first, last) exclusive of first"
    },
    {
        "Category": "Modifiers",
        "Function": "resize",
        "Signature": "void resize(size_type count)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Resizes forward_list to contain count elements",
        "Arguments": "count: new size",
        "Return Type": "void",
        "When to Use": "Change size; trim excess",
        "When NOT to Use": "Just adding elements (use push_front)",
        "Example": "fl.resize(100); fl.resize(50);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Must traverse entire list"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(forward_list& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another forward_list",
        "Arguments": "other: forward_list to swap with",
        "Return Type": "void",
        "When to Use": "Exchange forward_lists",
        "When NOT to Use": "Different types",
        "Example": "fl1.swap(fl2);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Constant time"
    },
    
    # ==================== OPERATIONS ====================
    {
        "Category": "Operations",
        "Function": "merge",
        "Signature": "void merge(forward_list& other)",
        "Time Complexity": "O(n + m)",
        "Space Complexity": "O(1)",
        "Description": "Merges two sorted forward_lists",
        "Arguments": "other: sorted forward_list to merge",
        "Return Type": "void",
        "When to Use": "Merge sorted lists; maintain sorted order",
        "When NOT to Use": "Lists not sorted",
        "Example": "fl1.merge(fl2); // both must be sorted",
        "Real World Frequency": 2,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Assumes both sorted; stable"
    },
    {
        "Category": "Operations",
        "Function": "splice_after (entire list)",
        "Signature": "void splice_after(const_iterator pos, forward_list& other)",
        "Time Complexity": "O(n) - must count elements",
        "Space Complexity": "O(1)",
        "Description": "Transfers all elements from other AFTER pos",
        "Arguments": "pos: position after which to insert; other: list to transfer from",
        "Return Type": "void",
        "When to Use": "Move entire list after position",
        "When NOT to Use": "Partial transfer",
        "Example": "fl1.splice_after(fl1.before_begin(), fl2);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "O(n) due to size tracking; relinks pointers"
    },
    {
        "Category": "Operations",
        "Function": "splice_after (single element)",
        "Signature": "void splice_after(const_iterator pos, forward_list& other, const_iterator it)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Transfers element AFTER it to AFTER pos",
        "Arguments": "pos: position; other: source list; it: before element to transfer",
        "Return Type": "void",
        "When to Use": "Move single element; O(1) transfer",
        "When NOT to Use": "Multiple elements",
        "Example": "fl1.splice_after(fl1.begin(), fl2, fl2.before_begin());",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "O(1); relinks pointers"
    },
    {
        "Category": "Operations",
        "Function": "remove",
        "Signature": "size_type remove(const T& value)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements equal to value",
        "Arguments": "value: value to remove",
        "Return Type": "size_type (count removed - C++20)",
        "When to Use": "Remove all occurrences of value",
        "When NOT to Use": "Remove by condition (use remove_if)",
        "Example": "fl.remove(42);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Returns count in C++20+"
    },
    {
        "Category": "Operations",
        "Function": "remove_if",
        "Signature": "size_type remove_if(UnaryPredicate pred)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements satisfying predicate",
        "Arguments": "pred: unary predicate function",
        "Return Type": "size_type (count removed - C++20)",
        "When to Use": "Remove by condition; filter list",
        "When NOT to Use": "Specific value (use remove)",
        "Example": "fl.remove_if([](int x) { return x % 2 == 0; });",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Returns count in C++20+"
    },
    {
        "Category": "Operations",
        "Function": "reverse",
        "Signature": "void reverse() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Reverses the order of elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reverse list; in-place reversal",
        "When NOT to Use": "Need copy",
        "Example": "fl.reverse();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "O(n); relinks pointers"
    },
    {
        "Category": "Operations",
        "Function": "unique",
        "Signature": "size_type unique()",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes consecutive duplicate elements",
        "Arguments": "None",
        "Return Type": "size_type (count removed - C++20)",
        "When to Use": "Remove consecutive duplicates; after sorting",
        "When NOT to Use": "Non-consecutive duplicates (sort first)",
        "Example": "fl.sort(); fl.unique();",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Only consecutive; returns count in C++20+"
    },
    {
        "Category": "Operations",
        "Function": "sort",
        "Signature": "void sort()",
        "Time Complexity": "O(n log n)",
        "Space Complexity": "O(1)",
        "Description": "Sorts elements in ascending order",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Sort forward_list; stable sort",
        "When NOT to Use": "Vector/list sufficient",
        "Example": "fl.sort();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "O(n log n); stable; member function"
    },
]


# ==============================================================================
# STRING CONTAINER - COMMONLY USED MEMBER FUNCTIONS
# ==============================================================================
string_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "string()",
        "Signature": "string()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty string",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty string; build dynamically",
        "When NOT to Use": "Have initial value (use literal)",
        "Example": "string s;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Dynamic character array; null-terminated internally"
    },
    {
        "Category": "Construction",
        "Function": "string(const char* s)",
        "Signature": "string(const char* s)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs string from C-string",
        "Arguments": "s: null-terminated C-string",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert C-string to string; most common",
        "When NOT to Use": "String literal (use \"\" directly)",
        "Example": "string s(\"hello\"); string s2 = \"world\";",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Copies characters; very common"
    },
    {
        "Category": "Construction",
        "Function": "string(size_t count, char c)",
        "Signature": "string(size_t count, char c)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs string with count copies of character",
        "Arguments": "count: number of characters; c: character to repeat",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create repeated character string",
        "When NOT to Use": "Empty or literal string",
        "Example": "string s(10, '*'); // \"**********\"",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Useful for padding, separators"
    },
    {
        "Category": "Construction",
        "Function": "string(substring)",
        "Signature": "string(const string& str, size_t pos, size_t len = npos)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs string from substring",
        "Arguments": "str: source string; pos: start position; len: length",
        "Return Type": "N/A (constructor)",
        "When to Use": "Extract substring during construction",
        "When NOT to Use": "Use substr() on existing string",
        "Example": "string s(\"hello world\", 0, 5); // \"hello\"",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Copies substring"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "operator[]",
        "Signature": "char& operator[](size_t pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access character at index (no bounds checking)",
        "Arguments": "pos: index of character",
        "Return Type": "reference to character",
        "When to Use": "Fast access; valid index guaranteed",
        "When NOT to Use": "Index might be invalid (use at())",
        "Example": "s[0] = 'H'; char c = s[2];",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "No bounds checking; undefined if out of range"
    },
    {
        "Category": "Element Access",
        "Function": "at",
        "Signature": "char& at(size_t pos)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access character at index with bounds checking",
        "Arguments": "pos: index of character",
        "Return Type": "reference to character",
        "When to Use": "Safe access; want exception on invalid index",
        "When NOT to Use": "Performance critical; index guaranteed valid",
        "Example": "try { char c = s.at(100); } catch(out_of_range&) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Throws out_of_range; safer than []"
    },
    {
        "Category": "Element Access",
        "Function": "front",
        "Signature": "char& front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access first character",
        "Arguments": "None",
        "Return Type": "reference to first character",
        "When to Use": "Access first character",
        "When NOT to Use": "String might be empty",
        "Example": "char first = s.front();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Undefined if empty; same as s[0]"
    },
    {
        "Category": "Element Access",
        "Function": "back",
        "Signature": "char& back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access last character",
        "Arguments": "None",
        "Return Type": "reference to last character",
        "When to Use": "Access last character",
        "When NOT to Use": "String might be empty",
        "Example": "char last = s.back();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Undefined if empty; same as s[s.size()-1]"
    },
    {
        "Category": "Element Access",
        "Function": "c_str",
        "Signature": "const char* c_str() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns null-terminated C-string",
        "Arguments": "None",
        "Return Type": "const char*",
        "When to Use": "Interface with C APIs; printf; file operations",
        "When NOT to Use": "C++ string operations",
        "Example": "printf(\"%s\", s.c_str()); FILE* f = fopen(s.c_str(), \"r\");",
        "Real World Frequency": 9,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Very common for C compatibility"
    },
    {
        "Category": "Element Access",
        "Function": "data",
        "Signature": "char* data() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns pointer to underlying character array",
        "Arguments": "None",
        "Return Type": "char* (non-const in C++17+)",
        "When to Use": "Low-level access; modify buffer directly (C++17+)",
        "When NOT to Use": "Normal string operations",
        "Example": "char* buf = s.data(); // C++17+",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98 (const), C++17 (non-const)",
        "Notes": "Modifiable in C++17+; same as c_str() in C++11+"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if string is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input",
        "When NOT to Use": "Need length",
        "Example": "if(!s.empty()) { char c = s[0]; }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size / length",
        "Signature": "size_t size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of characters (size() and length() are identical)",
        "Arguments": "None",
        "Return Type": "size_t",
        "When to Use": "Get character count; loop bounds",
        "When NOT to Use": "Checking if empty",
        "Example": "for(size_t i = 0; i < s.size(); ++i) { }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "size() and length() are identical; constant time"
    },
    {
        "Category": "Capacity",
        "Function": "capacity",
        "Signature": "size_t capacity() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns allocated storage capacity",
        "Arguments": "None",
        "Return Type": "size_t",
        "When to Use": "Check allocated space; optimization",
        "When NOT to Use": "Normal operations",
        "Example": "cout << s.capacity();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Always >= size(); implementation-dependent"
    },
    {
        "Category": "Capacity",
        "Function": "reserve",
        "Signature": "void reserve(size_t new_cap)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Reserves storage capacity",
        "Arguments": "new_cap: requested capacity",
        "Return Type": "void",
        "When to Use": "Pre-allocate; avoid reallocations; know final size",
        "When NOT to Use": "Unknown final size",
        "Example": "s.reserve(1000); // avoid reallocations",
        "Real World Frequency": 6,
        "DSA Training Frequency": 5,
        "C++ Version": "C++98",
        "Notes": "Performance optimization; very useful"
    },
    {
        "Category": "Capacity",
        "Function": "shrink_to_fit",
        "Signature": "void shrink_to_fit()",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Requests removal of unused capacity",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reduce memory usage; finished modifying",
        "When NOT to Use": "Will modify more",
        "Example": "s.shrink_to_fit();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "Non-binding request"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all characters",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset string; reuse",
        "When NOT to Use": "Will delete anyway",
        "Example": "s.clear();",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Size becomes 0; capacity unchanged"
    },
    {
        "Category": "Modifiers",
        "Function": "push_back",
        "Signature": "void push_back(char c)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Appends character to end",
        "Arguments": "c: character to append",
        "Return Type": "void",
        "When to Use": "Build string character by character",
        "When NOT to Use": "Append string (use +=)",
        "Example": "s.push_back('!');",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Amortized O(1); may reallocate"
    },
    {
        "Category": "Modifiers",
        "Function": "pop_back",
        "Signature": "void pop_back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes last character",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove last character",
        "When NOT to Use": "String might be empty",
        "Example": "if(!s.empty()) s.pop_back();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Undefined if empty"
    },
    {
        "Category": "Modifiers",
        "Function": "operator+=",
        "Signature": "string& operator+=(const string& str)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1) amortized",
        "Description": "Appends string or character",
        "Arguments": "str: string or character to append",
        "Return Type": "reference to this",
        "When to Use": "Concatenate strings; most common append",
        "When NOT to Use": "Building from many parts (use reserve + append)",
        "Example": "s += \" world\"; s += '!';",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Very common; works with string, C-string, char"
    },
    {
        "Category": "Modifiers",
        "Function": "append",
        "Signature": "string& append(const string& str)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1) amortized",
        "Description": "Appends string",
        "Arguments": "str: string to append",
        "Return Type": "reference to this",
        "When to Use": "Append string; chainable",
        "When NOT to Use": "Simple case (use +=)",
        "Example": "s.append(\"hello\").append(\" world\");",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Similar to +=; more options (substring, repeat)"
    },
    {
        "Category": "Modifiers",
        "Function": "insert",
        "Signature": "string& insert(size_t pos, const string& str)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts string at position",
        "Arguments": "pos: position to insert; str: string to insert",
        "Return Type": "reference to this",
        "When to Use": "Insert in middle",
        "When NOT to Use": "Insert at end (use +=)",
        "Example": "s.insert(5, \" there\");",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "O(n); shifts characters"
    },
    {
        "Category": "Modifiers",
        "Function": "erase",
        "Signature": "string& erase(size_t pos = 0, size_t len = npos)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Erases characters from string",
        "Arguments": "pos: start position; len: number of characters",
        "Return Type": "reference to this",
        "When to Use": "Remove substring; delete characters",
        "When NOT to Use": "Clear entire string (use clear)",
        "Example": "s.erase(5, 3); s.erase(5); // erase from pos to end",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "O(n); shifts characters"
    },
    {
        "Category": "Modifiers",
        "Function": "replace",
        "Signature": "string& replace(size_t pos, size_t len, const string& str)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Replaces portion of string",
        "Arguments": "pos: start position; len: length to replace; str: replacement",
        "Return Type": "reference to this",
        "When to Use": "Replace substring",
        "When NOT to Use": "Simple search-replace (use find + replace loop)",
        "Example": "s.replace(0, 5, \"goodbye\");",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "O(n); can change length"
    },
    {
        "Category": "Modifiers",
        "Function": "resize",
        "Signature": "void resize(size_t n, char c = '\\0')",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Resizes string to n characters",
        "Arguments": "n: new size; c: fill character if expanding",
        "Return Type": "void",
        "When to Use": "Change size; pre-allocate with content",
        "When NOT to Use": "Just capacity (use reserve)",
        "Example": "s.resize(100, ' '); s.resize(50);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Adds fill chars or truncates"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(string& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another string",
        "Arguments": "other: string to swap with",
        "Return Type": "void",
        "When to Use": "Exchange strings; optimize moves",
        "When NOT to Use": "Different types",
        "Example": "s1.swap(s2);",
        "Real World Frequency": 5,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Constant time"
    },
    
    # ==================== OPERATIONS ====================
    {
        "Category": "Operations",
        "Function": "substr",
        "Signature": "string substr(size_t pos = 0, size_t len = npos) const",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Returns substring",
        "Arguments": "pos: start position; len: length",
        "Return Type": "string",
        "When to Use": "Extract substring; very common",
        "When NOT to Use": "Just need view (use string_view in C++17+)",
        "Example": "string sub = s.substr(0, 5); string rest = s.substr(5);",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Creates new string; very common"
    },
    {
        "Category": "Operations",
        "Function": "find",
        "Signature": "size_t find(const string& str, size_t pos = 0) const noexcept",
        "Time Complexity": "O(n*m) worst case",
        "Space Complexity": "O(1)",
        "Description": "Finds first occurrence of substring",
        "Arguments": "str: substring to find; pos: start position",
        "Return Type": "size_t (position or npos)",
        "When to Use": "Search for substring; check if contains",
        "When NOT to Use": "Find all occurrences (loop with find)",
        "Example": "size_t pos = s.find(\"hello\"); if(pos != string::npos) { }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Returns npos if not found; very common"
    },
    {
        "Category": "Operations",
        "Function": "rfind",
        "Signature": "size_t rfind(const string& str, size_t pos = npos) const noexcept",
        "Time Complexity": "O(n*m)",
        "Space Complexity": "O(1)",
        "Description": "Finds last occurrence of substring",
        "Arguments": "str: substring to find; pos: end position",
        "Return Type": "size_t (position or npos)",
        "When to Use": "Search from end; find file extension",
        "When NOT to Use": "Forward search (use find)",
        "Example": "size_t pos = s.rfind('.'); // find last dot",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "Searches backwards; useful for extensions"
    },
    {
        "Category": "Operations",
        "Function": "find_first_of",
        "Signature": "size_t find_first_of(const string& chars, size_t pos = 0) const noexcept",
        "Time Complexity": "O(n*m)",
        "Space Complexity": "O(1)",
        "Description": "Finds first character matching any in chars",
        "Arguments": "chars: characters to search for; pos: start position",
        "Return Type": "size_t (position or npos)",
        "When to Use": "Find any of multiple characters; tokenization",
        "When NOT to Use": "Single character (use find)",
        "Example": "size_t pos = s.find_first_of(\"aeiou\"); // first vowel",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Very useful for parsing"
    },
    {
        "Category": "Operations",
        "Function": "find_last_of",
        "Signature": "size_t find_last_of(const string& chars, size_t pos = npos) const noexcept",
        "Time Complexity": "O(n*m)",
        "Space Complexity": "O(1)",
        "Description": "Finds last character matching any in chars",
        "Arguments": "chars: characters to search for; pos: end position",
        "Return Type": "size_t (position or npos)",
        "When to Use": "Find any from end; path parsing",
        "When NOT to Use": "Forward search (use find_first_of)",
        "Example": "size_t pos = s.find_last_of(\"/\\\\\"); // last path separator",
        "Real World Frequency": 6,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Useful for file paths"
    },
    {
        "Category": "Operations",
        "Function": "compare",
        "Signature": "int compare(const string& str) const noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Compares strings lexicographically",
        "Arguments": "str: string to compare",
        "Return Type": "int (<0, 0, >0)",
        "When to Use": "Three-way comparison; sorting",
        "When NOT to Use": "Equality (use == or !=)",
        "Example": "if(s1.compare(s2) < 0) { } // s1 < s2",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++98",
        "Notes": "Returns <0, 0, >0; use operators for clarity"
    },
    {
        "Category": "Operations",
        "Function": "starts_with",
        "Signature": "bool starts_with(const string& prefix) const noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if string starts with prefix",
        "Arguments": "prefix: prefix to check",
        "Return Type": "bool",
        "When to Use": "Check prefix; clean and readable",
        "When NOT to Use": "C++17 and earlier (use substr or compare)",
        "Example": "if(s.starts_with(\"http://\")) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++20",
        "Notes": "Modern; cleaner than substr comparison"
    },
    {
        "Category": "Operations",
        "Function": "ends_with",
        "Signature": "bool ends_with(const string& suffix) const noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Checks if string ends with suffix",
        "Arguments": "suffix: suffix to check",
        "Return Type": "bool",
        "When to Use": "Check suffix; file extensions; clean and readable",
        "When NOT to Use": "C++17 and earlier (use substr or compare)",
        "Example": "if(s.ends_with(\".txt\")) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++20",
        "Notes": "Modern; cleaner than substr comparison"
    },
]


# ==============================================================================
# STACK CONTAINER ADAPTER - ALL MEMBER FUNCTIONS
# ==============================================================================
stack_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "stack()",
        "Signature": "stack()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty stack",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty stack; LIFO operations",
        "When NOT to Use": "Need random access (use vector); need FIFO (use queue)",
        "Example": "stack<int> st;",
        "Real World Frequency": 8,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Container adapter; default underlying container is deque"
    },
    {
        "Category": "Construction",
        "Function": "stack(const Container& cont)",
        "Signature": "explicit stack(const Container& cont)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs stack from container",
        "Arguments": "cont: container to copy",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize stack from existing container",
        "When NOT to Use": "Empty stack (use default constructor)",
        "Example": "deque<int> d = {1,2,3}; stack<int> st(d);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Copies container; underlying container must support back(), push_back(), pop_back()"
    },
    {
        "Category": "Construction",
        "Function": "stack(Container&& cont)",
        "Signature": "explicit stack(Container&& cont)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Constructs stack by moving container",
        "Arguments": "cont: container to move from",
        "Return Type": "N/A (constructor)",
        "When to Use": "Transfer ownership from container",
        "When NOT to Use": "Need to keep original container",
        "Example": "stack<int> st(std::move(d));",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Move semantics; efficient transfer"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "top",
        "Signature": "reference top()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access top element (most recently added)",
        "Arguments": "None",
        "Return Type": "reference to top element",
        "When to Use": "View/modify top element; check before pop",
        "When NOT to Use": "Stack might be empty",
        "Example": "if(!st.empty()) { int x = st.top(); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; most commonly used with push/pop"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if stack is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before top() or pop(); loop condition",
        "When NOT to Use": "Need count (use size())",
        "Example": "while(!st.empty()) { int x = st.top(); st.pop(); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Always check before top/pop; very common pattern"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get element count; capacity planning",
        "When NOT to Use": "Just checking if empty (use empty())",
        "Example": "cout << \"Stack has \" << st.size() << \" elements\";",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Constant time"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "push",
        "Signature": "void push(const T& value)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Adds element to top of stack",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add elements; build stack; LIFO operations",
        "When NOT to Use": "Need FIFO (use queue)",
        "Example": "st.push(42); st.push(100);",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Most fundamental stack operation; O(1) amortized"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "void emplace(Args&&... args)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place at top",
        "Arguments": "args: arguments for constructor",
        "Return Type": "void",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types (push is fine)",
        "Example": "st.emplace(arg1, arg2); // constructs in-place",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; more efficient than push for complex types"
    },
    {
        "Category": "Modifiers",
        "Function": "pop",
        "Signature": "void pop()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes top element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove top element; LIFO processing",
        "When NOT to Use": "Stack might be empty",
        "Example": "if(!st.empty()) st.pop();",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Does NOT return value; use top() first; undefined if empty"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(stack& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another stack",
        "Arguments": "other: stack to swap with",
        "Return Type": "void",
        "When to Use": "Exchange stacks efficiently",
        "When NOT to Use": "Different types",
        "Example": "st1.swap(st2);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps underlying containers"
    },
]


# ==============================================================================
# QUEUE CONTAINER ADAPTER - ALL MEMBER FUNCTIONS
# ==============================================================================
queue_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "queue()",
        "Signature": "queue()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty queue",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty queue; FIFO operations",
        "When NOT to Use": "Need LIFO (use stack); need priority (use priority_queue)",
        "Example": "queue<int> q;",
        "Real World Frequency": 9,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Container adapter; default underlying container is deque"
    },
    {
        "Category": "Construction",
        "Function": "queue(const Container& cont)",
        "Signature": "explicit queue(const Container& cont)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs queue from container",
        "Arguments": "cont: container to copy",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize queue from existing container",
        "When NOT to Use": "Empty queue (use default constructor)",
        "Example": "deque<int> d = {1,2,3}; queue<int> q(d);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++98",
        "Notes": "Copies container; underlying must support front(), back(), push_back(), pop_front()"
    },
    {
        "Category": "Construction",
        "Function": "queue(Container&& cont)",
        "Signature": "explicit queue(Container&& cont)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Constructs queue by moving container",
        "Arguments": "cont: container to move from",
        "Return Type": "N/A (constructor)",
        "When to Use": "Transfer ownership from container",
        "When NOT to Use": "Need to keep original container",
        "Example": "queue<int> q(std::move(d));",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Move semantics; efficient transfer"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "front",
        "Signature": "reference front()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access first element (next to be removed)",
        "Arguments": "None",
        "Return Type": "reference to front element",
        "When to Use": "View/modify front element; check before pop",
        "When NOT to Use": "Queue might be empty",
        "Example": "if(!q.empty()) { int x = q.front(); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; element to be removed by pop()"
    },
    {
        "Category": "Element Access",
        "Function": "back",
        "Signature": "reference back()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access last element (most recently added)",
        "Arguments": "None",
        "Return Type": "reference to back element",
        "When to Use": "View/modify most recent element",
        "When NOT to Use": "Queue might be empty",
        "Example": "if(!q.empty()) { int x = q.back(); }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; unique to queue (stack has no back)"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if queue is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before front()/back()/pop(); loop condition",
        "When NOT to Use": "Need count (use size())",
        "Example": "while(!q.empty()) { int x = q.front(); q.pop(); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Always check before front/back/pop; very common in BFS"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get element count; BFS level tracking",
        "When NOT to Use": "Just checking if empty (use empty())",
        "Example": "int level_size = q.size(); // BFS level",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "Constant time; useful in BFS for level-order traversal"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "push",
        "Signature": "void push(const T& value)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Adds element to back of queue",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add elements; enqueue; FIFO operations",
        "When NOT to Use": "Need LIFO (use stack)",
        "Example": "q.push(42); q.push(100);",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Enqueue operation; O(1) amortized; very common in BFS"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "void emplace(Args&&... args)",
        "Time Complexity": "O(1) amortized",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place at back",
        "Arguments": "args: arguments for constructor",
        "Return Type": "void",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types (push is fine)",
        "Example": "q.emplace(arg1, arg2); // constructs in-place",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; more efficient than push for complex types"
    },
    {
        "Category": "Modifiers",
        "Function": "pop",
        "Signature": "void pop()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Removes front element",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove front element; dequeue; FIFO processing",
        "When NOT to Use": "Queue might be empty",
        "Example": "if(!q.empty()) q.pop();",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Dequeue operation; does NOT return value; use front() first"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(queue& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another queue",
        "Arguments": "other: queue to swap with",
        "Return Type": "void",
        "When to Use": "Exchange queues efficiently",
        "When NOT to Use": "Different types",
        "Example": "q1.swap(q2);",
        "Real World Frequency": 3,
        "DSA Training Frequency": 3,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps underlying containers"
    },
]


# ==============================================================================
# PRIORITY_QUEUE CONTAINER ADAPTER - ALL MEMBER FUNCTIONS
# ==============================================================================
priority_queue_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "priority_queue()",
        "Signature": "priority_queue()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty max-heap priority queue",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create priority queue; need max element access; heap operations",
        "When NOT to Use": "Need FIFO (use queue); need LIFO (use stack); need sorted order",
        "Example": "priority_queue<int> pq; // max-heap by default",
        "Real World Frequency": 8,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Container adapter; default: max-heap; underlying container: vector"
    },
    {
        "Category": "Construction",
        "Function": "priority_queue(Compare comp)",
        "Signature": "priority_queue(const Compare& comp)",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Constructs priority queue with custom comparator",
        "Arguments": "comp: comparison function object",
        "Return Type": "N/A (constructor)",
        "When to Use": "Need min-heap or custom ordering",
        "When NOT to Use": "Default max-heap sufficient",
        "Example": "priority_queue<int, vector<int>, greater<int>> pq; // min-heap",
        "Real World Frequency": 7,
        "DSA Training Frequency": 9,
        "C++ Version": "C++98",
        "Notes": "greater<int> creates min-heap; very common pattern"
    },
    {
        "Category": "Construction",
        "Function": "priority_queue(Iterator first, Iterator last)",
        "Signature": "priority_queue(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs priority queue from range (heapify)",
        "Arguments": "first, last: range of elements",
        "Return Type": "N/A (constructor)",
        "When to Use": "Build heap from existing data",
        "When NOT to Use": "Empty queue (use default constructor)",
        "Example": "priority_queue<int> pq(v.begin(), v.end());",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++98",
        "Notes": "O(n) heapify; efficient bulk construction"
    },
    {
        "Category": "Construction",
        "Function": "priority_queue(initializer_list)",
        "Signature": "priority_queue(initializer_list<T> init)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs priority queue from initializer list",
        "Arguments": "init: initializer list with values",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known values; test cases",
        "When NOT to Use": "Large datasets",
        "Example": "priority_queue<int> pq = {3, 1, 4, 1, 5};",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "O(n) heapify"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "top",
        "Signature": "const_reference top() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Access top element (max in max-heap, min in min-heap)",
        "Arguments": "None",
        "Return Type": "const reference to top element",
        "When to Use": "View highest priority element; check before pop",
        "When NOT to Use": "Queue might be empty",
        "Example": "if(!pq.empty()) { int max = pq.top(); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Undefined if empty; const reference only (no modification)"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if priority queue is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before top() or pop(); loop condition",
        "When NOT to Use": "Need count (use size())",
        "Example": "while(!pq.empty()) { int x = pq.top(); pq.pop(); }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "Always check before top/pop; very common in Dijkstra, A*"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get element count; algorithm termination",
        "When NOT to Use": "Just checking if empty (use empty())",
        "Example": "cout << \"Priority queue has \" << pq.size() << \" elements\";",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++98",
        "Notes": "Constant time"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "push",
        "Signature": "void push(const T& value)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Inserts element and maintains heap property",
        "Arguments": "value: element to add",
        "Return Type": "void",
        "When to Use": "Add elements; build heap; priority operations",
        "When NOT to Use": "Need O(1) insertion (use queue/stack)",
        "Example": "pq.push(42); pq.push(100);",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "O(log n); heap up operation; very common in graph algorithms"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "void emplace(Args&&... args)",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place and maintains heap property",
        "Arguments": "args: arguments for constructor",
        "Return Type": "void",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types (push is fine)",
        "Example": "pq.emplace(arg1, arg2); // constructs in-place",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++11",
        "Notes": "O(log n); perfect forwarding"
    },
    {
        "Category": "Modifiers",
        "Function": "pop",
        "Signature": "void pop()",
        "Time Complexity": "O(log n)",
        "Space Complexity": "O(1)",
        "Description": "Removes top element and maintains heap property",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Remove highest priority element; heap operations",
        "When NOT to Use": "Queue might be empty",
        "Example": "if(!pq.empty()) pq.pop();",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++98",
        "Notes": "O(log n); heap down; does NOT return value; use top() first"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(priority_queue& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another priority queue",
        "Arguments": "other: priority queue to swap with",
        "Return Type": "void",
        "When to Use": "Exchange priority queues efficiently",
        "When NOT to Use": "Different types or comparators",
        "Example": "pq1.swap(pq2);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++98",
        "Notes": "Constant time; swaps underlying containers"
    },
]


# ==============================================================================
# UNORDERED_MAP CONTAINER - COMMONLY USED MEMBER FUNCTIONS
# ==============================================================================
unordered_map_functions = [
    # ==================== CONSTRUCTORS ====================
    {
        "Category": "Construction",
        "Function": "unordered_map()",
        "Signature": "unordered_map()",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Default constructor - creates empty hash table",
        "Arguments": "None",
        "Return Type": "N/A (constructor)",
        "When to Use": "Create empty hash map; O(1) average lookup; order not important",
        "When NOT to Use": "Need sorted order (use map); few elements (overhead)",
        "Example": "unordered_map<string, int> um;",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "Hash table; average O(1) access; no ordering"
    },
    {
        "Category": "Construction",
        "Function": "unordered_map(initializer_list)",
        "Signature": "unordered_map(initializer_list<pair<const Key, T>> init)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs unordered_map from initializer list",
        "Arguments": "init: initializer list of key-value pairs",
        "Return Type": "N/A (constructor)",
        "When to Use": "Initialize with known key-value pairs; test cases",
        "When NOT to Use": "Large datasets; dynamic data",
        "Example": "unordered_map<string, int> um = {{\"a\", 1}, {\"b\", 2}};",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Modern syntax; very convenient"
    },
    {
        "Category": "Construction",
        "Function": "unordered_map(Iterator first, Iterator last)",
        "Signature": "unordered_map(InputIterator first, InputIterator last)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Constructs unordered_map from range",
        "Arguments": "first, last: range of key-value pairs",
        "Return Type": "N/A (constructor)",
        "When to Use": "Convert range to hash map",
        "When NOT to Use": "Copy entire map (use copy constructor)",
        "Example": "unordered_map<int, int> um(v.begin(), v.end());",
        "Real World Frequency": 4,
        "DSA Training Frequency": 5,
        "C++ Version": "C++11",
        "Notes": "Copies pairs from range"
    },
    {
        "Category": "Construction",
        "Function": "unordered_map(size_t bucket_count)",
        "Signature": "explicit unordered_map(size_type bucket_count)",
        "Time Complexity": "O(n) where n = bucket_count",
        "Space Complexity": "O(n)",
        "Description": "Constructs with minimum bucket count",
        "Arguments": "bucket_count: minimum number of buckets",
        "Return Type": "N/A (constructor)",
        "When to Use": "Know expected size; optimize performance; avoid rehashing",
        "When NOT to Use": "Unknown size",
        "Example": "unordered_map<int, int> um(1000); // pre-allocate",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++11",
        "Notes": "Performance optimization; reduces rehashing"
    },
    
    # ==================== ELEMENT ACCESS ====================
    {
        "Category": "Element Access",
        "Function": "operator[]",
        "Signature": "T& operator[](const Key& key)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Access or insert element with key (creates if not exists)",
        "Arguments": "key: key of element",
        "Return Type": "reference to mapped value",
        "When to Use": "Access/modify value; insert with default; very common",
        "When NOT to Use": "Check existence without insert (use find); const map",
        "Example": "um[\"key\"] = 42; int x = um[\"key\"];",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "INSERTS if key doesn't exist; very common; non-const only"
    },
    {
        "Category": "Element Access",
        "Function": "at",
        "Signature": "T& at(const Key& key)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Access element with bounds checking (throws if not exists)",
        "Arguments": "key: key of element",
        "Return Type": "reference to mapped value",
        "When to Use": "Safe access; want exception if key missing",
        "When NOT to Use": "Key might not exist and that's ok (use find or [])",
        "Example": "try { int x = um.at(\"key\"); } catch(out_of_range&) { }",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Throws out_of_range; does NOT insert; safer than []"
    },
    
    # ==================== ITERATORS ====================
    {
        "Category": "Iterators",
        "Function": "begin",
        "Signature": "iterator begin() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to first element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Iterate all elements; range-based for",
        "When NOT to Use": "Need sorted iteration (use map)",
        "Example": "for(auto it = um.begin(); it != um.end(); ++it) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "No guaranteed order; prefer range-based for"
    },
    {
        "Category": "Iterators",
        "Function": "end",
        "Signature": "iterator end() noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns iterator to one past last element",
        "Arguments": "None",
        "Return Type": "iterator",
        "When to Use": "Loop termination; range operations",
        "When NOT to Use": "Accessing elements",
        "Example": "for(auto& [k, v] : um) { } // range-based for",
        "Real World Frequency": 8,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Past-the-end iterator"
    },
    
    # ==================== CAPACITY ====================
    {
        "Category": "Capacity",
        "Function": "empty",
        "Signature": "bool empty() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Checks if unordered_map is empty",
        "Arguments": "None",
        "Return Type": "bool",
        "When to Use": "Check before access; validate input",
        "When NOT to Use": "Need count",
        "Example": "if(!um.empty()) { }",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Preferred over size() == 0"
    },
    {
        "Category": "Capacity",
        "Function": "size",
        "Signature": "size_type size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Get element count; frequency counting",
        "When NOT to Use": "Checking if empty",
        "Example": "cout << um.size();",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Constant time; very common"
    },
    {
        "Category": "Capacity",
        "Function": "max_size",
        "Signature": "size_type max_size() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns maximum possible number of elements",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Theoretical limit checking; rarely used",
        "When NOT to Use": "Normal size checks",
        "Example": "size_t max = um.max_size();",
        "Real World Frequency": 1,
        "DSA Training Frequency": 1,
        "C++ Version": "C++11",
        "Notes": "Implementation defined"
    },
    
    # ==================== MODIFIERS ====================
    {
        "Category": "Modifiers",
        "Function": "clear",
        "Signature": "void clear() noexcept",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(1)",
        "Description": "Removes all elements",
        "Arguments": "None",
        "Return Type": "void",
        "When to Use": "Reset map; reuse container",
        "When NOT to Use": "Will delete anyway",
        "Example": "um.clear();",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++11",
        "Notes": "Size becomes 0; buckets may remain allocated"
    },
    {
        "Category": "Modifiers",
        "Function": "insert (value)",
        "Signature": "pair<iterator, bool> insert(const value_type& value)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Inserts element if key doesn't exist",
        "Arguments": "value: pair<Key, T> to insert",
        "Return Type": "pair of iterator and bool (success)",
        "When to Use": "Insert without overwriting; check if inserted",
        "When NOT to Use": "Want to overwrite (use [] or insert_or_assign)",
        "Example": "auto [it, inserted] = um.insert({\"key\", 42});",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Returns pair: iterator to element, bool if inserted"
    },
    {
        "Category": "Modifiers",
        "Function": "insert_or_assign",
        "Signature": "pair<iterator, bool> insert_or_assign(const Key& k, T&& obj)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Inserts or assigns to element with key",
        "Arguments": "k: key; obj: value to insert or assign",
        "Return Type": "pair of iterator and bool (inserted vs assigned)",
        "When to Use": "Insert or update value; modern alternative to []",
        "When NOT to Use": "Don't want to overwrite existing",
        "Example": "um.insert_or_assign(\"key\", 42);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 8,
        "C++ Version": "C++17",
        "Notes": "C++17; cleaner than []; returns if inserted or updated"
    },
    {
        "Category": "Modifiers",
        "Function": "emplace",
        "Signature": "pair<iterator, bool> emplace(Args&&... args)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Constructs element in-place if key doesn't exist",
        "Arguments": "args: arguments for pair constructor",
        "Return Type": "pair of iterator and bool (success)",
        "When to Use": "Construct complex objects; avoid copies",
        "When NOT to Use": "Simple types; want to overwrite",
        "Example": "um.emplace(\"key\", 42); um.emplace(piecewise_construct, ...);",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Perfect forwarding; only inserts if key doesn't exist"
    },
    {
        "Category": "Modifiers",
        "Function": "try_emplace",
        "Signature": "pair<iterator, bool> try_emplace(const Key& k, Args&&... args)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Constructs value in-place if key doesn't exist",
        "Arguments": "k: key; args: arguments for mapped_type constructor",
        "Return Type": "pair of iterator and bool (success)",
        "When to Use": "Construct value only if inserting; efficient",
        "When NOT to Use": "Simple types (use insert)",
        "Example": "um.try_emplace(\"key\", arg1, arg2); // constructs value",
        "Real World Frequency": 5,
        "DSA Training Frequency": 6,
        "C++ Version": "C++17",
        "Notes": "C++17; doesn't construct if key exists; very efficient"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (key)",
        "Signature": "size_type erase(const Key& key)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Removes element with key",
        "Arguments": "key: key of element to remove",
        "Return Type": "number of elements removed (0 or 1)",
        "When to Use": "Remove by key; very common",
        "When NOT to Use": "Key might not exist and need to know (check first)",
        "Example": "um.erase(\"key\"); if(um.erase(\"key\")) { }",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Returns 0 if not found, 1 if erased"
    },
    {
        "Category": "Modifiers",
        "Function": "erase (iterator)",
        "Signature": "iterator erase(const_iterator pos)",
        "Time Complexity": "O(1) average",
        "Space Complexity": "O(1)",
        "Description": "Removes element at iterator position",
        "Arguments": "pos: iterator to element to remove",
        "Return Type": "iterator following removed element",
        "When to Use": "Remove during iteration; have iterator",
        "When NOT to Use": "Have key (use erase(key))",
        "Example": "auto it = um.find(\"key\"); if(it != um.end()) um.erase(it);",
        "Real World Frequency": 7,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Returns iterator; safe during iteration"
    },
    {
        "Category": "Modifiers",
        "Function": "swap",
        "Signature": "void swap(unordered_map& other) noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Swaps contents with another unordered_map",
        "Arguments": "other: unordered_map to swap with",
        "Return Type": "void",
        "When to Use": "Exchange maps efficiently",
        "When NOT to Use": "Different key/value types",
        "Example": "um1.swap(um2);",
        "Real World Frequency": 4,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Constant time"
    },
    
    # ==================== LOOKUP ====================
    {
        "Category": "Lookup",
        "Function": "count",
        "Signature": "size_type count(const Key& key) const",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Returns number of elements with key (0 or 1)",
        "Arguments": "key: key to search for",
        "Return Type": "size_type (0 or 1)",
        "When to Use": "Check if key exists; readable",
        "When NOT to Use": "Need element (use find); multimap (can be > 1)",
        "Example": "if(um.count(\"key\")) { } // key exists",
        "Real World Frequency": 9,
        "DSA Training Frequency": 9,
        "C++ Version": "C++11",
        "Notes": "Returns 0 or 1; very common for existence check"
    },
    {
        "Category": "Lookup",
        "Function": "find",
        "Signature": "iterator find(const Key& key)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Finds element with key",
        "Arguments": "key: key to search for",
        "Return Type": "iterator to element or end()",
        "When to Use": "Find and access element; check existence; very common",
        "When NOT to Use": "Just checking existence (count is more readable)",
        "Example": "auto it = um.find(\"key\"); if(it != um.end()) { int v = it->second; }",
        "Real World Frequency": 10,
        "DSA Training Frequency": 10,
        "C++ Version": "C++11",
        "Notes": "Returns end() if not found; most common lookup method"
    },
    {
        "Category": "Lookup",
        "Function": "contains",
        "Signature": "bool contains(const Key& key) const",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Checks if key exists",
        "Arguments": "key: key to search for",
        "Return Type": "bool",
        "When to Use": "Check existence; clean and readable; modern C++",
        "When NOT to Use": "C++17 and earlier (use count or find)",
        "Example": "if(um.contains(\"key\")) { }",
        "Real World Frequency": 8,
        "DSA Training Frequency": 9,
        "C++ Version": "C++20",
        "Notes": "C++20; cleaner than count; preferred for existence check"
    },
    {
        "Category": "Lookup",
        "Function": "equal_range",
        "Signature": "pair<iterator, iterator> equal_range(const Key& key)",
        "Time Complexity": "O(1) average, O(n) worst",
        "Space Complexity": "O(1)",
        "Description": "Returns range of elements with key",
        "Arguments": "key: key to search for",
        "Return Type": "pair of iterators (begin, end of range)",
        "When to Use": "Consistent interface with map; rarely needed",
        "When NOT to Use": "unordered_map has unique keys (use find)",
        "Example": "auto [first, last] = um.equal_range(\"key\");",
        "Real World Frequency": 2,
        "DSA Training Frequency": 2,
        "C++ Version": "C++11",
        "Notes": "For unordered_map, range has at most 1 element"
    },
    
    # ==================== BUCKET INTERFACE ====================
    {
        "Category": "Bucket Interface",
        "Function": "bucket_count",
        "Signature": "size_type bucket_count() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns number of buckets",
        "Arguments": "None",
        "Return Type": "size_type",
        "When to Use": "Hash table analysis; performance tuning",
        "When NOT to Use": "Normal operations",
        "Example": "cout << um.bucket_count();",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Implementation-specific; useful for diagnostics"
    },
    {
        "Category": "Bucket Interface",
        "Function": "load_factor",
        "Signature": "float load_factor() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns average number of elements per bucket",
        "Arguments": "None",
        "Return Type": "float",
        "When to Use": "Performance analysis; hash table health",
        "When NOT to Use": "Normal operations",
        "Example": "float lf = um.load_factor(); // size() / bucket_count()",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Equals size() / bucket_count(); indicator of performance"
    },
    {
        "Category": "Bucket Interface",
        "Function": "max_load_factor",
        "Signature": "float max_load_factor() const noexcept",
        "Time Complexity": "O(1)",
        "Space Complexity": "O(1)",
        "Description": "Returns or sets maximum load factor",
        "Arguments": "None (getter)",
        "Return Type": "float",
        "When to Use": "Performance tuning; control rehashing",
        "When NOT to Use": "Default is usually fine",
        "Example": "float mlf = um.max_load_factor(); um.max_load_factor(0.75);",
        "Real World Frequency": 2,
        "DSA Training Frequency": 3,
        "C++ Version": "C++11",
        "Notes": "Default ~1.0; triggers rehash when exceeded"
    },
    {
        "Category": "Bucket Interface",
        "Function": "rehash",
        "Signature": "void rehash(size_type count)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Sets number of buckets and rehashes",
        "Arguments": "count: minimum number of buckets",
        "Return Type": "void",
        "When to Use": "Pre-allocate buckets; avoid automatic rehashing",
        "When NOT to Use": "Unknown final size",
        "Example": "um.rehash(1000); // optimize for ~1000 elements",
        "Real World Frequency": 3,
        "DSA Training Frequency": 4,
        "C++ Version": "C++11",
        "Notes": "Expensive operation; use reserve instead when possible"
    },
    {
        "Category": "Bucket Interface",
        "Function": "reserve",
        "Signature": "void reserve(size_type count)",
        "Time Complexity": "O(n)",
        "Space Complexity": "O(n)",
        "Description": "Reserves space for at least count elements",
        "Arguments": "count: number of elements to reserve for",
        "Return Type": "void",
        "When to Use": "Know expected size; avoid rehashing; performance",
        "When NOT to Use": "Unknown size",
        "Example": "um.reserve(1000); // avoid rehashing for 1000 elements",
        "Real World Frequency": 6,
        "DSA Training Frequency": 7,
        "C++ Version": "C++11",
        "Notes": "Very useful; equivalent to rehash(ceil(count/max_load_factor))"
    },
]


def create_excel_catalog():
    """Creates the Excel workbook with formatted sheets"""
    
    output_file = Path("cpp_dsa_functions_catalog.xlsx")
    
    # Create DataFrames
    df_algorithms = pd.DataFrame(algorithm_functions)
    df_vector = pd.DataFrame(vector_functions)
    df_map = pd.DataFrame(map_functions)
    df_set = pd.DataFrame(set_functions)
    df_unordered_set = pd.DataFrame(unordered_set_functions)
    df_multiset = pd.DataFrame(multiset_functions)
    df_multimap = pd.DataFrame(multimap_functions)
    df_deque = pd.DataFrame(deque_functions)
    df_list = pd.DataFrame(list_functions)
    df_forward_list = pd.DataFrame(forward_list_functions)
    df_string = pd.DataFrame(string_functions)
    df_stack = pd.DataFrame(stack_functions)
    df_queue = pd.DataFrame(queue_functions)
    df_priority_queue = pd.DataFrame(priority_queue_functions)
    df_unordered_map = pd.DataFrame(unordered_map_functions)
    
    # Write to Excel
    with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
        df_algorithms.to_excel(writer, sheet_name='Algorithm Library', index=False)
        df_vector.to_excel(writer, sheet_name='Vector', index=False)
        df_map.to_excel(writer, sheet_name='Map', index=False)
        df_set.to_excel(writer, sheet_name='Set', index=False)
        df_unordered_set.to_excel(writer, sheet_name='Unordered Set', index=False)
        df_multiset.to_excel(writer, sheet_name='Multiset', index=False)
        df_multimap.to_excel(writer, sheet_name='Multimap', index=False)
        df_deque.to_excel(writer, sheet_name='Deque', index=False)
        df_list.to_excel(writer, sheet_name='List', index=False)
        df_forward_list.to_excel(writer, sheet_name='Forward List', index=False)
        df_string.to_excel(writer, sheet_name='String', index=False)
        df_stack.to_excel(writer, sheet_name='Stack', index=False)
        df_queue.to_excel(writer, sheet_name='Queue', index=False)
        df_priority_queue.to_excel(writer, sheet_name='Priority Queue', index=False)
        df_unordered_map.to_excel(writer, sheet_name='Unordered Map', index=False)
    
    # Load workbook for formatting
    wb = load_workbook(output_file)
    format_sheet(wb['Algorithm Library'])
    format_sheet(wb['Vector'])
    format_sheet(wb['Map'])
    format_sheet(wb['Set'])
    format_sheet(wb['Unordered Set'])
    format_sheet(wb['Multiset'])
    format_sheet(wb['Multimap'])
    format_sheet(wb['Deque'])
    format_sheet(wb['List'])
    format_sheet(wb['Forward List'])
    format_sheet(wb['String'])
    format_sheet(wb['Stack'])
    format_sheet(wb['Queue'])
    format_sheet(wb['Priority Queue'])
    format_sheet(wb['Unordered Map'])
    
    # Save formatted workbook
    wb.save(output_file)
    print(f"✓ Created: {output_file}")
    print(f"  - Algorithm Library: {len(algorithm_functions)} functions")
    print(f"  - Vector: {len(vector_functions)} member functions")
    print(f"  - Map: {len(map_functions)} member functions")
    print(f"  - Set: {len(set_functions)} member functions")
    print(f"  - Unordered Set: {len(unordered_set_functions)} member functions")
    print(f"  - Multiset: {len(multiset_functions)} member functions")
    print(f"  - Multimap: {len(multimap_functions)} member functions")
    print(f"  - Deque: {len(deque_functions)} member functions")
    print(f"  - List: {len(list_functions)} member functions")
    print(f"  - Forward List: {len(forward_list_functions)} member functions")
    print(f"  - String: {len(string_functions)} member functions")
    print(f"  - Stack: {len(stack_functions)} member functions")
    print(f"  - Queue: {len(queue_functions)} member functions")
    print(f"  - Priority Queue: {len(priority_queue_functions)} member functions")
    print(f"  - Unordered Map: {len(unordered_map_functions)} member functions")


def format_sheet(ws):
    """Apply professional formatting to worksheet"""
    
    # Define colors
    header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")
    category_fills = {
        # Algorithm Library categories
        "Sorting": PatternFill(start_color="E8F8F5", end_color="E8F8F5", fill_type="solid"),
        "Searching": PatternFill(start_color="FEF9E7", end_color="FEF9E7", fill_type="solid"),
        "Min/Max": PatternFill(start_color="FDF2E9", end_color="FDF2E9", fill_type="solid"),
        "Permutation": PatternFill(start_color="F4ECF7", end_color="F4ECF7", fill_type="solid"),
        "Heap": PatternFill(start_color="E8F6F3", end_color="E8F6F3", fill_type="solid"),
        "Set Operations": PatternFill(start_color="EBF5FB", end_color="EBF5FB", fill_type="solid"),
        "Numeric": PatternFill(start_color="FADBD8", end_color="FADBD8", fill_type="solid"),
        "Partitioning": PatternFill(start_color="F9E79F", end_color="F9E79F", fill_type="solid"),
        "Comparison": PatternFill(start_color="D5F4E6", end_color="D5F4E6", fill_type="solid"),
        "Copy/Move": PatternFill(start_color="FAE5D3", end_color="FAE5D3", fill_type="solid"),
        "Fill/Generate": PatternFill(start_color="EBDEF0", end_color="EBDEF0", fill_type="solid"),
        "Transform": PatternFill(start_color="D6EAF8", end_color="D6EAF8", fill_type="solid"),
        # Vector categories
        "Construction": PatternFill(start_color="E8F8F5", end_color="E8F8F5", fill_type="solid"),
        "Element Access": PatternFill(start_color="FEF9E7", end_color="FEF9E7", fill_type="solid"),
        "Iterators": PatternFill(start_color="FDF2E9", end_color="FDF2E9", fill_type="solid"),
        "Capacity": PatternFill(start_color="F4ECF7", end_color="F4ECF7", fill_type="solid"),
        "Modifiers": PatternFill(start_color="E8F6F3", end_color="E8F6F3", fill_type="solid"),
        # Map/Set categories
        "Lookup": PatternFill(start_color="FCF3CF", end_color="FCF3CF", fill_type="solid"),
        "Observers": PatternFill(start_color="D5F4E6", end_color="D5F4E6", fill_type="solid"),
        # Unordered containers categories
        "Bucket Interface": PatternFill(start_color="E8DAEF", end_color="E8DAEF", fill_type="solid"),
        "Hash Policy": PatternFill(start_color="D6EAF8", end_color="D6EAF8", fill_type="solid"),
    }
    
    # Header row formatting
    header_font = Font(bold=True, color="FFFFFF", size=11)
    for cell in ws[1]:
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
    
    # Border style
    thin_border = Border(
        left=Side(style='thin', color='CCCCCC'),
        right=Side(style='thin', color='CCCCCC'),
        top=Side(style='thin', color='CCCCCC'),
        bottom=Side(style='thin', color='CCCCCC')
    )
    
    # Format data rows
    for row_idx, row in enumerate(ws.iter_rows(min_row=2, max_row=ws.max_row), start=2):
        category = ws[f'A{row_idx}'].value
        row_fill = category_fills.get(category, PatternFill())
        
        for cell in row:
            cell.border = thin_border
            cell.fill = row_fill
            cell.alignment = Alignment(vertical="top", wrap_text=True)
    
    # Column widths - adapt based on sheet content
    if ws.max_column >= 16:  # Algorithm Library sheet
        column_widths = {
            'A': 15,  # Category
            'B': 22,  # Function
            'C': 12,  # Header
            'D': 50,  # Signature
            'E': 18,  # Time Complexity
            'F': 18,  # Space Complexity
            'G': 60,  # Description
            'H': 70,  # Arguments
            'I': 15,  # Return Type
            'J': 60,  # When to Use
            'K': 60,  # When NOT to Use
            'L': 65,  # Example
            'M': 12,  # Real World Frequency
            'N': 12,  # DSA Training Frequency
            'O': 12,  # C++ Version
            'P': 50,  # Notes
        }
    else:  # Vector or other container sheets
        column_widths = {
            'A': 15,  # Category
            'B': 30,  # Function
            'C': 55,  # Signature
            'D': 18,  # Time Complexity
            'E': 18,  # Space Complexity
            'F': 60,  # Description
            'G': 70,  # Arguments
            'H': 20,  # Return Type
            'I': 60,  # When to Use
            'J': 60,  # When NOT to Use
            'K': 65,  # Example
            'L': 12,  # Real World Frequency
            'M': 12,  # DSA Training Frequency
            'N': 12,  # C++ Version
            'O': 50,  # Notes
        }
    
    for col_letter, width in column_widths.items():
        if ord(col_letter) - ord('A') < ws.max_column:
            ws.column_dimensions[col_letter].width = width
    
    # Set row heights
    ws.row_dimensions[1].height = 40
    for row in range(2, ws.max_row + 1):
        ws.row_dimensions[row].height = 60
    
    # Freeze panes (freeze first row and first column)
    ws.freeze_panes = 'B2'
    
    # Add autofilter
    ws.auto_filter.ref = ws.dimensions


if __name__ == "__main__":
    print("=" * 70)
    print("C++ DSA Functions Catalog Generator")
    print("=" * 70)
    print()
    
    create_excel_catalog()
    
    print()
    print("=" * 70)
    print("✓ Catalog generated successfully!")
    print("=" * 70)
